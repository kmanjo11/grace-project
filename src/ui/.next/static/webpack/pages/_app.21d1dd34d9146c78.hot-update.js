"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "(pages-dir-browser)/./components/AuthContext.tsx":
/*!************************************!*\
  !*** ./components/AuthContext.tsx ***!
  \************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthProvider: () => (/* binding */ AuthProvider),\n/* harmony export */   useAuth: () => (/* binding */ useAuth)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/.pnpm/react@19.1.1/node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/.pnpm/react@19.1.1/node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _api_apiClient__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../api/apiClient */ \"(pages-dir-browser)/./api/apiClient.ts\");\n/* harmony import */ var _utils_devAuth__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/devAuth */ \"(pages-dir-browser)/./utils/devAuth.ts\");\n/* harmony import */ var _utils_authUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/authUtils */ \"(pages-dir-browser)/./utils/authUtils.ts\");\n// src/ui/components/AuthContext.tsx\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\n// Import admin backdoor utilities\n\n// Import standardized auth utils\n\nconst TOKEN_EXPIRY_KEY = 'grace_token_expiry';\nconst REFRESH_TOKEN_KEY = 'grace_refresh_token';\nconst TOKEN_VERIFY_INTERVAL = 60000; // Check token validity every 60 seconds\n// Improved session persistence utility to avoid conflicts with form state\nconst SessionPersistence = {\n    STORAGE_KEY: 'GRACE_SESSION_SNAPSHOT',\n    // Safely capture session snapshot with minimal data to avoid interference\n    captureSnapshot (user, token) {\n        try {\n            if (!user || !token) {\n                this.clearSnapshot();\n                return;\n            }\n            // Store only essential user identification data\n            // Avoid storing complete state that might conflict with forms\n            const snapshot = {\n                timestamp: Date.now(),\n                user: {\n                    id: user.id,\n                    username: user.username,\n                    email: user.email\n                },\n                // Don't store the actual token, just indicate authentication\n                authenticated: true\n            };\n            // Use sessionStorage instead of localStorage to avoid persisting between browser sessions\n            // This helps prevent stale data from affecting forms on future visits\n            sessionStorage.setItem(this.STORAGE_KEY, JSON.stringify(snapshot));\n        } catch (error) {\n            console.warn('Failed to capture session snapshot', error);\n        // Silently fail - don't let snapshot errors affect the application\n        }\n    },\n    // Retrieve session snapshot with validation\n    retrieveSnapshot () {\n        try {\n            const snapshotStr = sessionStorage.getItem(this.STORAGE_KEY);\n            if (!snapshotStr) return {\n                user: null,\n                token: null\n            };\n            const snapshot = JSON.parse(snapshotStr);\n            // Validate snapshot with expiration check (30 minutes)\n            const MAX_AGE = 30 * 60 * 1000; // 30 minutes in milliseconds\n            const isExpired = Date.now() - (snapshot.timestamp || 0) > MAX_AGE;\n            if (snapshot && snapshot.user && !isExpired) {\n                return {\n                    user: snapshot.user,\n                    // Get actual token from authUtils to ensure consistency\n                    token: (0,_utils_authUtils__WEBPACK_IMPORTED_MODULE_4__.getAuthToken)()\n                };\n            }\n            // Clear expired snapshot\n            if (isExpired) this.clearSnapshot();\n            return {\n                user: null,\n                token: null\n            };\n        } catch (error) {\n            console.warn('Failed to retrieve session snapshot', error);\n            this.clearSnapshot(); // Clear invalid snapshot\n            return {\n                user: null,\n                token: null\n            };\n        }\n    },\n    // Clear session snapshot\n    clearSnapshot () {\n        try {\n            sessionStorage.removeItem(this.STORAGE_KEY);\n        } catch (error) {\n            console.warn('Failed to clear session snapshot', error);\n        }\n    }\n};\nconst AuthContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\nfunction AuthProvider(param) {\n    let { children } = param;\n    _s();\n    const [user, setUser] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [isAuthenticated, setIsAuthenticated] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Use state for token to ensure it's updated when changed\n    const [token, setToken] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)((0,_utils_authUtils__WEBPACK_IMPORTED_MODULE_4__.getAuthToken)());\n    // Add flag to prevent verification immediately after login\n    const [skipNextVerification, setSkipNextVerification] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Update token state whenever auth state changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"AuthProvider.useEffect\": ()=>{\n            setToken((0,_utils_authUtils__WEBPACK_IMPORTED_MODULE_4__.getAuthToken)());\n        }\n    }[\"AuthProvider.useEffect\"], [\n        isAuthenticated\n    ]);\n    // Admin backdoor for quick access\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"AuthProvider.useEffect\": ()=>{\n            // Check if we should use the admin backdoor\n            if ((0,_utils_devAuth__WEBPACK_IMPORTED_MODULE_3__.hasAdminBypass)() && !isAuthenticated && !token) {\n                (0,_utils_devAuth__WEBPACK_IMPORTED_MODULE_3__.bypassLogin)(login);\n            }\n        }\n    }[\"AuthProvider.useEffect\"], []);\n    // Verify auth tokens on mount and set interval\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"AuthProvider.useEffect\": ()=>{\n            let isMounted = true;\n            const verifyOnMount = {\n                \"AuthProvider.useEffect.verifyOnMount\": async ()=>{\n                    // Skip initial verification if there's no token\n                    if ( true && !(0,_utils_authUtils__WEBPACK_IMPORTED_MODULE_4__.getAuthToken)()) {\n                        console.log('AuthContext: No token found on mount, skipping verification');\n                        if (isMounted) setLoading(false);\n                        return;\n                    }\n                    console.log('AuthContext: Verifying token on mount');\n                    // Verify token on component mount\n                    await verifyToken();\n                    // Handle case where verification completed but component was unmounted\n                    if (isMounted) setLoading(false);\n                }\n            }[\"AuthProvider.useEffect.verifyOnMount\"];\n            verifyOnMount();\n            // Set up periodic token verification\n            const interval = setInterval({\n                \"AuthProvider.useEffect.interval\": ()=>{\n                    if (!skipNextVerification) {\n                        verifyToken();\n                    } else {\n                        // Reset skip flag after using it once\n                        setSkipNextVerification(false);\n                    }\n                }\n            }[\"AuthProvider.useEffect.interval\"], TOKEN_VERIFY_INTERVAL);\n            return ({\n                \"AuthProvider.useEffect\": ()=>{\n                    isMounted = false;\n                    clearInterval(interval);\n                }\n            })[\"AuthProvider.useEffect\"];\n        }\n    }[\"AuthProvider.useEffect\"], []);\n    // Verify user token with backend\n    const verifyToken = async ()=>{\n        // If no token exists, there's nothing to verify\n        const token = (0,_utils_authUtils__WEBPACK_IMPORTED_MODULE_4__.getAuthToken)();\n        if (!token) {\n            console.log('AuthContext: No token to verify');\n            setIsAuthenticated(false);\n            setUser(null);\n            setLoading(false);\n            return false;\n        }\n        try {\n            console.log('AuthContext: Verifying token with backend');\n            setLoading(true);\n            const response = await _api_apiClient__WEBPACK_IMPORTED_MODULE_2__[\"default\"].get(_api_apiClient__WEBPACK_IMPORTED_MODULE_2__.API_ENDPOINTS.AUTH.VERIFY_TOKEN);\n            if (response.success && response.data) {\n                // Token is valid, update user data\n                console.log('AuthContext: Token verified successfully');\n                setIsAuthenticated(true);\n                setUser(response.data.user || {});\n                setToken(token); // Ensure token state matches storage\n                return true;\n            }\n            var _response_statusCode;\n            // Non-success HTTP response\n            const status = (_response_statusCode = response.statusCode) !== null && _response_statusCode !== void 0 ? _response_statusCode : 0;\n            if (status === 401 || status === 403) {\n                console.log('AuthContext: Token verification failed with unauthorized status:', status);\n                clearAuthState();\n                return false;\n            }\n            // For other errors (5xx, 0, etc.), keep current auth state to avoid flicker\n            console.warn('AuthContext: Verification non-success but not unauthorized. Preserving auth state.', {\n                status,\n                error: response.error\n            });\n            return false;\n        } catch (error) {\n            // Network or unexpected error: preserve current auth state\n            const msg = error instanceof Error ? error.message : 'Unknown error';\n            console.error('Token verification error, preserving auth state:', msg);\n            return false;\n        } finally{\n            setLoading(false);\n        }\n    };\n    // Enhanced logging utility for authentication events\n    const logAuthEvent = function(eventType) {\n        let details = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        const timestamp = new Date().toISOString();\n        const logEntry = {\n            timestamp,\n            eventType,\n            ...details\n        };\n        // Optional: Send to backend logging service or store locally\n        console.log(JSON.stringify(logEntry));\n        // Store in local storage for potential debugging\n        try {\n            const authLogs = JSON.parse(localStorage.getItem('auth_logs') || '[]');\n            authLogs.push(logEntry);\n            // Keep only last 50 log entries\n            localStorage.setItem('auth_logs', JSON.stringify(authLogs.slice(-50)));\n        } catch (e) {\n            console.error('Failed to log authentication event', e);\n        }\n    };\n    // Check if user has a wallet and generate one if not available\n    const checkAndGenerateWallet = async ()=>{\n        try {\n            var _walletResponse_data_wallet, _walletResponse_data;\n            // Skip if not authenticated\n            if (!isAuthenticated || !token) {\n                return;\n            }\n            // First check if wallet already exists\n            const walletResponse = await _api_apiClient__WEBPACK_IMPORTED_MODULE_2__[\"default\"].get(_api_apiClient__WEBPACK_IMPORTED_MODULE_2__.API_ENDPOINTS.WALLET.INFO, {});\n            // If no wallet or wallet address is empty, generate a new one\n            if (!walletResponse.success || !((_walletResponse_data = walletResponse.data) === null || _walletResponse_data === void 0 ? void 0 : (_walletResponse_data_wallet = _walletResponse_data.wallet) === null || _walletResponse_data_wallet === void 0 ? void 0 : _walletResponse_data_wallet.wallet_address)) {\n                console.log('No wallet found for user, generating a new internal wallet...');\n                // Generate a new wallet\n                const generateResponse = await _api_apiClient__WEBPACK_IMPORTED_MODULE_2__[\"default\"].post(_api_apiClient__WEBPACK_IMPORTED_MODULE_2__.API_ENDPOINTS.WALLET.GENERATE, {});\n                if (generateResponse.success) {\n                    var _generateResponse_data_wallet, _generateResponse_data, _generateResponse_data1;\n                    console.log('Wallet generated successfully:', (_generateResponse_data = generateResponse.data) === null || _generateResponse_data === void 0 ? void 0 : (_generateResponse_data_wallet = _generateResponse_data.wallet) === null || _generateResponse_data_wallet === void 0 ? void 0 : _generateResponse_data_wallet.wallet_address);\n                    // You could set wallet info in state here if needed\n                    return (_generateResponse_data1 = generateResponse.data) === null || _generateResponse_data1 === void 0 ? void 0 : _generateResponse_data1.wallet;\n                } else {\n                    console.error('Failed to generate wallet:', generateResponse.error);\n                }\n            } else {\n                var _walletResponse_data_wallet1, _walletResponse_data1, _walletResponse_data2;\n                console.log('User wallet already exists:', (_walletResponse_data1 = walletResponse.data) === null || _walletResponse_data1 === void 0 ? void 0 : (_walletResponse_data_wallet1 = _walletResponse_data1.wallet) === null || _walletResponse_data_wallet1 === void 0 ? void 0 : _walletResponse_data_wallet1.wallet_address);\n                return (_walletResponse_data2 = walletResponse.data) === null || _walletResponse_data2 === void 0 ? void 0 : _walletResponse_data2.wallet;\n            }\n        } catch (error) {\n            console.error('Error checking/generating wallet:', error instanceof Error ? error.message : 'Unknown error');\n        }\n    };\n    // Implement token refresh functionality with exponential backoff\n    const refreshToken = async function() {\n        let retryCount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;\n        const MAX_RETRIES = 3;\n        const BASE_DELAY = 1000; // 1 second initial delay\n        try {\n            var _response_data;\n            logAuthEvent('TOKEN_REFRESH_ATTEMPT', {\n                retryCount\n            });\n            // Exponential backoff with jitter\n            if (retryCount > 0) {\n                const delay = BASE_DELAY * Math.pow(2, retryCount) * (1 + Math.random());\n                await new Promise((resolve)=>setTimeout(resolve, delay));\n            }\n            // Use the dedicated refresh token endpoint\n            const response = await _api_apiClient__WEBPACK_IMPORTED_MODULE_2__[\"default\"].post(_api_apiClient__WEBPACK_IMPORTED_MODULE_2__.API_ENDPOINTS.AUTH.REFRESH_TOKEN, {});\n            if (!response.success || !((_response_data = response.data) === null || _response_data === void 0 ? void 0 : _response_data.token)) {\n                throw new Error('Token refresh failed: Invalid response');\n            }\n            const { token, username } = response.data;\n            // Determine storage type based on where the current token is stored\n            const inLocalStorage = localStorage.getItem(_utils_authUtils__WEBPACK_IMPORTED_MODULE_4__.TOKEN_KEY) !== null;\n            const rememberMe = inLocalStorage; // If in localStorage, user wanted persistent login\n            // Store the new token with the same preference\n            await (0,_utils_authUtils__WEBPACK_IMPORTED_MODULE_4__.storeAuthToken)(token, rememberMe);\n            // Update local token state\n            setToken(token);\n            setIsAuthenticated(true);\n            // Optional: Update username if provided\n            if (username) {\n                setUser((prevUser)=>({\n                        ...prevUser,\n                        username\n                    }));\n            }\n            logAuthEvent('TOKEN_REFRESH_SUCCESS', {\n                username\n            });\n            return true;\n        } catch (error) {\n            const errorMessage = error instanceof Error ? error.message : 'Unknown refresh error';\n            logAuthEvent('TOKEN_REFRESH_FAILURE', {\n                errorMessage,\n                retryCount,\n                errorStack: error instanceof Error ? error.stack : undefined\n            });\n            // Implement retry mechanism\n            if (retryCount < MAX_RETRIES) {\n                console.warn(\"Token refresh attempt \".concat(retryCount + 1, \" failed. Retrying...\"));\n                return refreshToken(retryCount + 1);\n            }\n            // Final fallback: logout after max retries\n            console.error('Token refresh failed after maximum retries');\n            logout();\n            return false;\n        }\n    };\n    // Login with credentials\n    const login = async (data)=>{\n        try {\n            console.log('AuthContext: login function called with data:', data);\n            // Some API clients save the token directly to storage and strip it from payload\n            // Fall back to reading from storage if not present on the response object\n            if (!data.token) {\n                const storedToken = (0,_utils_authUtils__WEBPACK_IMPORTED_MODULE_4__.getAuthToken)();\n                console.log('AuthContext: token missing in payload, using stored token:', !!storedToken);\n                if (storedToken) {\n                    data.token = storedToken;\n                } else {\n                    throw new Error('No token found in login data or storage');\n                }\n            }\n            console.log('AuthContext: Processing login with token');\n            // Store token with remember me preference if provided\n            const rememberMe = data.remember_me !== undefined ? data.remember_me : true; // Default to true for persistent login\n            // Store token and wait for it to complete\n            await (0,_utils_authUtils__WEBPACK_IMPORTED_MODULE_4__.storeAuthToken)(data.token, rememberMe);\n            console.log('AuthContext: Token stored successfully');\n            // Update application state\n            setToken(data.token); // Ensure token state is synchronized\n            setUser(data.user || {});\n            setIsAuthenticated(true);\n            setLoading(false); // Ensure loading state is turned off\n            console.log('AuthContext: State updated - isAuthenticated: true, user:', data.user);\n            // Capture minimal session data after successful login\n            if (data.user) {\n                SessionPersistence.captureSnapshot(data.user, data.token);\n            }\n            // Set flag to skip next verification cycle to avoid race condition\n            setSkipNextVerification(true);\n            // Log successful login state update\n            console.log('AuthContext: Login complete, auth state updated');\n            // Automatically check for wallet and generate if needed\n            // This ensures every user has a wallet automatically\n            setTimeout(()=>{\n                checkAndGenerateWallet();\n            }, 500); // Small delay to ensure auth is fully established\n            return true; // Signal successful login\n        } catch (error) {\n            console.error('Login failed:', error instanceof Error ? error.message : 'Unknown error');\n            // Ensure auth state is reset if login fails\n            (0,_utils_authUtils__WEBPACK_IMPORTED_MODULE_4__.clearAuthTokens)();\n            SessionPersistence.clearSnapshot();\n            setToken(null);\n            setUser(null);\n            setIsAuthenticated(false);\n            setLoading(false);\n            return false; // Signal failed login\n        }\n    };\n    // Clear auth state - reusable function for both logout and failed auth\n    const clearAuthState = ()=>{\n        (0,_utils_authUtils__WEBPACK_IMPORTED_MODULE_4__.clearAuthTokens)();\n        setToken(null);\n        setUser(null);\n        setIsAuthenticated(false);\n        SessionPersistence.clearSnapshot();\n    };\n    // Clear auth state\n    const logout = async ()=>{\n        logAuthEvent('logout_initiated');\n        try {\n            // Attempt to call logout endpoint if we have a token\n            if ((0,_utils_authUtils__WEBPACK_IMPORTED_MODULE_4__.getAuthToken)()) {\n                await _api_apiClient__WEBPACK_IMPORTED_MODULE_2__[\"default\"].post(_api_apiClient__WEBPACK_IMPORTED_MODULE_2__.API_ENDPOINTS.AUTH.LOGOUT, {});\n            }\n        } catch (error) {\n            console.error('Error during logout:', error);\n        // Continue with logout regardless of API errors\n        } finally{\n            // Always clear local state and storage\n            clearAuthState();\n            // Log the event\n            logAuthEvent('logout_complete');\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(AuthContext.Provider, {\n        value: {\n            user,\n            login,\n            logout,\n            loading,\n            refreshToken,\n            isAuthenticated\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/wonkasworld/Downloads/grace-project/src/ui/components/AuthContext.tsx\",\n        lineNumber: 447,\n        columnNumber: 5\n    }, this);\n}\n_s(AuthProvider, \"weT8k2eN96VyKLNkgO1xu2THofc=\");\n_c = AuthProvider;\nconst useAuth = ()=>{\n    _s1();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(AuthContext);\n    if (!context) {\n        throw new Error('useAuth must be used within an AuthProvider');\n    }\n    return context;\n};\n_s1(useAuth, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"AuthProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvQXV0aENvbnRleHQudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBLG9DQUFvQzs7O0FBRTBDO0FBQzdCO0FBQ2Q7QUFDbkMsa0NBQWtDO0FBQzZCO0FBQy9ELGlDQUFpQztBQVNMO0FBRTVCLE1BQU1hLG1CQUFtQjtBQUN6QixNQUFNQyxvQkFBb0I7QUFDMUIsTUFBTUMsd0JBQXdCLE9BQU8sd0NBQXdDO0FBRTdFLDBFQUEwRTtBQUMxRSxNQUFNQyxxQkFBcUI7SUFDekJDLGFBQWE7SUFFYiwwRUFBMEU7SUFDMUVDLGlCQUFnQkMsSUFBaUIsRUFBRUMsS0FBb0I7UUFDckQsSUFBSTtZQUNGLElBQUksQ0FBQ0QsUUFBUSxDQUFDQyxPQUFPO2dCQUNuQixJQUFJLENBQUNDLGFBQWE7Z0JBQ2xCO1lBQ0Y7WUFFQSxnREFBZ0Q7WUFDaEQsOERBQThEO1lBQzlELE1BQU1DLFdBQVc7Z0JBQ2ZDLFdBQVdDLEtBQUtDLEdBQUc7Z0JBQ25CTixNQUFNO29CQUNKTyxJQUFJUCxLQUFLTyxFQUFFO29CQUNYQyxVQUFVUixLQUFLUSxRQUFRO29CQUN2QkMsT0FBT1QsS0FBS1MsS0FBSztnQkFDbkI7Z0JBQ0EsNkRBQTZEO2dCQUM3REMsZUFBZTtZQUNqQjtZQUVBLDBGQUEwRjtZQUMxRixzRUFBc0U7WUFDdEVDLGVBQWVDLE9BQU8sQ0FBQyxJQUFJLENBQUNkLFdBQVcsRUFBRWUsS0FBS0MsU0FBUyxDQUFDWDtRQUMxRCxFQUFFLE9BQU9ZLE9BQU87WUFDZEMsUUFBUUMsSUFBSSxDQUFDLHNDQUFzQ0Y7UUFDbkQsbUVBQW1FO1FBQ3JFO0lBQ0Y7SUFFQSw0Q0FBNEM7SUFDNUNHO1FBQ0UsSUFBSTtZQUNGLE1BQU1DLGNBQWNSLGVBQWVTLE9BQU8sQ0FBQyxJQUFJLENBQUN0QixXQUFXO1lBQzNELElBQUksQ0FBQ3FCLGFBQWEsT0FBTztnQkFBRW5CLE1BQU07Z0JBQU1DLE9BQU87WUFBSztZQUVuRCxNQUFN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RG93bmxvYWRzL2dyYWNlLXByb2plY3Qvc3JjL3VpL2NvbXBvbmVudHMvQXV0aENvbnRleHQudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy91aS9jb21wb25lbnRzL0F1dGhDb250ZXh0LnRzeFxuXG5pbXBvcnQgUmVhY3QsIHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEFQSV9FTkRQT0lOVFMgfSBmcm9tICcuLi9hcGkvYXBpQ2xpZW50JztcbmltcG9ydCBhcGkgZnJvbSAnLi4vYXBpL2FwaUNsaWVudCc7XG4vLyBJbXBvcnQgYWRtaW4gYmFja2Rvb3IgdXRpbGl0aWVzXG5pbXBvcnQgeyBoYXNBZG1pbkJ5cGFzcywgYnlwYXNzTG9naW4gfSBmcm9tICcuLi91dGlscy9kZXZBdXRoJztcbi8vIEltcG9ydCBzdGFuZGFyZGl6ZWQgYXV0aCB1dGlsc1xuaW1wb3J0IHtcbiAgZ2V0QXV0aFRva2VuLFxuICBnZXRUb2tlbkV4cGlyeSxcbiAgc3RvcmVBdXRoVG9rZW4sXG4gIGNsZWFyQXV0aFRva2VucyxcbiAgaXNUb2tlbkV4cGlyZWQsXG4gIGFkZEF1dGhIZWFkZXJzLFxuICBUT0tFTl9LRVlcbn0gZnJvbSAnLi4vdXRpbHMvYXV0aFV0aWxzJztcblxuY29uc3QgVE9LRU5fRVhQSVJZX0tFWSA9ICdncmFjZV90b2tlbl9leHBpcnknO1xuY29uc3QgUkVGUkVTSF9UT0tFTl9LRVkgPSAnZ3JhY2VfcmVmcmVzaF90b2tlbic7XG5jb25zdCBUT0tFTl9WRVJJRllfSU5URVJWQUwgPSA2MDAwMDsgLy8gQ2hlY2sgdG9rZW4gdmFsaWRpdHkgZXZlcnkgNjAgc2Vjb25kc1xuXG4vLyBJbXByb3ZlZCBzZXNzaW9uIHBlcnNpc3RlbmNlIHV0aWxpdHkgdG8gYXZvaWQgY29uZmxpY3RzIHdpdGggZm9ybSBzdGF0ZVxuY29uc3QgU2Vzc2lvblBlcnNpc3RlbmNlID0ge1xuICBTVE9SQUdFX0tFWTogJ0dSQUNFX1NFU1NJT05fU05BUFNIT1QnLFxuICBcbiAgLy8gU2FmZWx5IGNhcHR1cmUgc2Vzc2lvbiBzbmFwc2hvdCB3aXRoIG1pbmltYWwgZGF0YSB0byBhdm9pZCBpbnRlcmZlcmVuY2VcbiAgY2FwdHVyZVNuYXBzaG90KHVzZXI6IFVzZXIgfCBudWxsLCB0b2tlbjogc3RyaW5nIHwgbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIXVzZXIgfHwgIXRva2VuKSB7XG4gICAgICAgIHRoaXMuY2xlYXJTbmFwc2hvdCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFN0b3JlIG9ubHkgZXNzZW50aWFsIHVzZXIgaWRlbnRpZmljYXRpb24gZGF0YVxuICAgICAgLy8gQXZvaWQgc3RvcmluZyBjb21wbGV0ZSBzdGF0ZSB0aGF0IG1pZ2h0IGNvbmZsaWN0IHdpdGggZm9ybXNcbiAgICAgIGNvbnN0IHNuYXBzaG90ID0ge1xuICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgIHVzZXI6IHtcbiAgICAgICAgICBpZDogdXNlci5pZCxcbiAgICAgICAgICB1c2VybmFtZTogdXNlci51c2VybmFtZSxcbiAgICAgICAgICBlbWFpbDogdXNlci5lbWFpbFxuICAgICAgICB9LFxuICAgICAgICAvLyBEb24ndCBzdG9yZSB0aGUgYWN0dWFsIHRva2VuLCBqdXN0IGluZGljYXRlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgIGF1dGhlbnRpY2F0ZWQ6IHRydWVcbiAgICAgIH07XG5cbiAgICAgIC8vIFVzZSBzZXNzaW9uU3RvcmFnZSBpbnN0ZWFkIG9mIGxvY2FsU3RvcmFnZSB0byBhdm9pZCBwZXJzaXN0aW5nIGJldHdlZW4gYnJvd3NlciBzZXNzaW9uc1xuICAgICAgLy8gVGhpcyBoZWxwcyBwcmV2ZW50IHN0YWxlIGRhdGEgZnJvbSBhZmZlY3RpbmcgZm9ybXMgb24gZnV0dXJlIHZpc2l0c1xuICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbSh0aGlzLlNUT1JBR0VfS0VZLCBKU09OLnN0cmluZ2lmeShzbmFwc2hvdCkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBjYXB0dXJlIHNlc3Npb24gc25hcHNob3QnLCBlcnJvcik7XG4gICAgICAvLyBTaWxlbnRseSBmYWlsIC0gZG9uJ3QgbGV0IHNuYXBzaG90IGVycm9ycyBhZmZlY3QgdGhlIGFwcGxpY2F0aW9uXG4gICAgfVxuICB9LFxuXG4gIC8vIFJldHJpZXZlIHNlc3Npb24gc25hcHNob3Qgd2l0aCB2YWxpZGF0aW9uXG4gIHJldHJpZXZlU25hcHNob3QoKTogeyB1c2VyOiBVc2VyIHwgbnVsbCwgdG9rZW46IHN0cmluZyB8IG51bGwgfSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNuYXBzaG90U3RyID0gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbSh0aGlzLlNUT1JBR0VfS0VZKTtcbiAgICAgIGlmICghc25hcHNob3RTdHIpIHJldHVybiB7IHVzZXI6IG51bGwsIHRva2VuOiBudWxsIH07XG5cbiAgICAgIGNvbnN0IHNuYXBzaG90ID0gSlNPTi5wYXJzZShzbmFwc2hvdFN0cik7XG4gICAgICBcbiAgICAgIC8vIFZhbGlkYXRlIHNuYXBzaG90IHdpdGggZXhwaXJhdGlvbiBjaGVjayAoMzAgbWludXRlcylcbiAgICAgIGNvbnN0IE1BWF9BR0UgPSAzMCAqIDYwICogMTAwMDsgLy8gMzAgbWludXRlcyBpbiBtaWxsaXNlY29uZHNcbiAgICAgIGNvbnN0IGlzRXhwaXJlZCA9IChEYXRlLm5vdygpIC0gKHNuYXBzaG90LnRpbWVzdGFtcCB8fCAwKSkgPiBNQVhfQUdFO1xuICAgICAgXG4gICAgICBpZiAoc25hcHNob3QgJiYgc25hcHNob3QudXNlciAmJiAhaXNFeHBpcmVkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdXNlcjogc25hcHNob3QudXNlcixcbiAgICAgICAgICAvLyBHZXQgYWN0dWFsIHRva2VuIGZyb20gYXV0aFV0aWxzIHRvIGVuc3VyZSBjb25zaXN0ZW5jeVxuICAgICAgICAgIHRva2VuOiBnZXRBdXRoVG9rZW4oKVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBDbGVhciBleHBpcmVkIHNuYXBzaG90XG4gICAgICBpZiAoaXNFeHBpcmVkKSB0aGlzLmNsZWFyU25hcHNob3QoKTtcbiAgICAgIHJldHVybiB7IHVzZXI6IG51bGwsIHRva2VuOiBudWxsIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHJldHJpZXZlIHNlc3Npb24gc25hcHNob3QnLCBlcnJvcik7XG4gICAgICB0aGlzLmNsZWFyU25hcHNob3QoKTsgLy8gQ2xlYXIgaW52YWxpZCBzbmFwc2hvdFxuICAgICAgcmV0dXJuIHsgdXNlcjogbnVsbCwgdG9rZW46IG51bGwgfTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gQ2xlYXIgc2Vzc2lvbiBzbmFwc2hvdFxuICBjbGVhclNuYXBzaG90KCkge1xuICAgIHRyeSB7XG4gICAgICBzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKHRoaXMuU1RPUkFHRV9LRVkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBjbGVhciBzZXNzaW9uIHNuYXBzaG90JywgZXJyb3IpO1xuICAgIH1cbiAgfVxufTtcblxuaW50ZXJmYWNlIFVzZXIge1xuICBpZD86IHN0cmluZztcbiAgdXNlcm5hbWU/OiBzdHJpbmc7XG4gIGVtYWlsPzogc3RyaW5nO1xuICBba2V5OiBzdHJpbmddOiBhbnk7XG59XG5cbmludGVyZmFjZSBBdXRoQ29udGV4dFR5cGUge1xuICB1c2VyOiBVc2VyIHwgbnVsbDtcbiAgbG9naW46IChkYXRhOiBhbnkpID0+IFByb21pc2U8Ym9vbGVhbj47XG4gIGxvZ291dDogKCkgPT4gdm9pZDtcbiAgbG9hZGluZzogYm9vbGVhbjtcbiAgcmVmcmVzaFRva2VuOiAoKSA9PiBQcm9taXNlPGJvb2xlYW4+O1xuICBpc0F1dGhlbnRpY2F0ZWQ6IGJvb2xlYW47XG59XG5cbmNvbnN0IEF1dGhDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxBdXRoQ29udGV4dFR5cGUgfCBudWxsPihudWxsKTtcblxuXG5leHBvcnQgZnVuY3Rpb24gQXV0aFByb3ZpZGVyKHsgY2hpbGRyZW4gfTogeyBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlIH0pIHtcbiAgY29uc3QgW3VzZXIsIHNldFVzZXJdID0gdXNlU3RhdGU8VXNlciB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZTxib29sZWFuPih0cnVlKTtcbiAgY29uc3QgW2lzQXV0aGVudGljYXRlZCwgc2V0SXNBdXRoZW50aWNhdGVkXSA9IHVzZVN0YXRlPGJvb2xlYW4+KGZhbHNlKTtcbiAgLy8gVXNlIHN0YXRlIGZvciB0b2tlbiB0byBlbnN1cmUgaXQncyB1cGRhdGVkIHdoZW4gY2hhbmdlZFxuICBjb25zdCBbdG9rZW4sIHNldFRva2VuXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KGdldEF1dGhUb2tlbigpKTtcbiAgLy8gQWRkIGZsYWcgdG8gcHJldmVudCB2ZXJpZmljYXRpb24gaW1tZWRpYXRlbHkgYWZ0ZXIgbG9naW5cbiAgY29uc3QgW3NraXBOZXh0VmVyaWZpY2F0aW9uLCBzZXRTa2lwTmV4dFZlcmlmaWNhdGlvbl0gPSB1c2VTdGF0ZTxib29sZWFuPihmYWxzZSk7XG4gIFxuICAvLyBVcGRhdGUgdG9rZW4gc3RhdGUgd2hlbmV2ZXIgYXV0aCBzdGF0ZSBjaGFuZ2VzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgc2V0VG9rZW4oZ2V0QXV0aFRva2VuKCkpO1xuICB9LCBbaXNBdXRoZW50aWNhdGVkXSk7XG4gIFxuICAvLyBBZG1pbiBiYWNrZG9vciBmb3IgcXVpY2sgYWNjZXNzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gQ2hlY2sgaWYgd2Ugc2hvdWxkIHVzZSB0aGUgYWRtaW4gYmFja2Rvb3JcbiAgICBpZiAoaGFzQWRtaW5CeXBhc3MoKSAmJiAhaXNBdXRoZW50aWNhdGVkICYmICF0b2tlbikge1xuICAgICAgYnlwYXNzTG9naW4obG9naW4pO1xuICAgIH1cbiAgfSwgW10pO1xuXG4gIC8vIFZlcmlmeSBhdXRoIHRva2VucyBvbiBtb3VudCBhbmQgc2V0IGludGVydmFsXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbGV0IGlzTW91bnRlZCA9IHRydWU7XG4gICAgXG4gICAgY29uc3QgdmVyaWZ5T25Nb3VudCA9IGFzeW5jICgpID0+IHtcbiAgICAgIC8vIFNraXAgaW5pdGlhbCB2ZXJpZmljYXRpb24gaWYgdGhlcmUncyBubyB0b2tlblxuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICFnZXRBdXRoVG9rZW4oKSkge1xuICAgICAgICBjb25zb2xlLmxvZygnQXV0aENvbnRleHQ6IE5vIHRva2VuIGZvdW5kIG9uIG1vdW50LCBza2lwcGluZyB2ZXJpZmljYXRpb24nKTtcbiAgICAgICAgaWYgKGlzTW91bnRlZCkgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ0F1dGhDb250ZXh0OiBWZXJpZnlpbmcgdG9rZW4gb24gbW91bnQnKTtcbiAgICAgIC8vIFZlcmlmeSB0b2tlbiBvbiBjb21wb25lbnQgbW91bnRcbiAgICAgIGF3YWl0IHZlcmlmeVRva2VuKCk7XG4gICAgICBcbiAgICAgIC8vIEhhbmRsZSBjYXNlIHdoZXJlIHZlcmlmaWNhdGlvbiBjb21wbGV0ZWQgYnV0IGNvbXBvbmVudCB3YXMgdW5tb3VudGVkXG4gICAgICBpZiAoaXNNb3VudGVkKSBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICB9O1xuICAgIFxuICAgIHZlcmlmeU9uTW91bnQoKTtcbiAgICBcbiAgICAvLyBTZXQgdXAgcGVyaW9kaWMgdG9rZW4gdmVyaWZpY2F0aW9uXG4gICAgY29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBpZiAoIXNraXBOZXh0VmVyaWZpY2F0aW9uKSB7XG4gICAgICAgIHZlcmlmeVRva2VuKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZXNldCBza2lwIGZsYWcgYWZ0ZXIgdXNpbmcgaXQgb25jZVxuICAgICAgICBzZXRTa2lwTmV4dFZlcmlmaWNhdGlvbihmYWxzZSk7XG4gICAgICB9XG4gICAgfSwgVE9LRU5fVkVSSUZZX0lOVEVSVkFMKTtcbiAgICBcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaXNNb3VudGVkID0gZmFsc2U7XG4gICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICB9O1xuICB9LCBbXSk7ICAgICBcblxuICAvLyBWZXJpZnkgdXNlciB0b2tlbiB3aXRoIGJhY2tlbmRcbiAgY29uc3QgdmVyaWZ5VG9rZW4gPSBhc3luYyAoKSA9PiB7XG4gICAgLy8gSWYgbm8gdG9rZW4gZXhpc3RzLCB0aGVyZSdzIG5vdGhpbmcgdG8gdmVyaWZ5XG4gICAgY29uc3QgdG9rZW4gPSBnZXRBdXRoVG9rZW4oKTtcbiAgICBpZiAoIXRva2VuKSB7XG4gICAgICBjb25zb2xlLmxvZygnQXV0aENvbnRleHQ6IE5vIHRva2VuIHRvIHZlcmlmeScpO1xuICAgICAgc2V0SXNBdXRoZW50aWNhdGVkKGZhbHNlKTtcbiAgICAgIHNldFVzZXIobnVsbCk7XG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJ0F1dGhDb250ZXh0OiBWZXJpZnlpbmcgdG9rZW4gd2l0aCBiYWNrZW5kJyk7XG4gICAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkuZ2V0KEFQSV9FTkRQT0lOVFMuQVVUSC5WRVJJRllfVE9LRU4pO1xuXG4gICAgICBpZiAocmVzcG9uc2Uuc3VjY2VzcyAmJiByZXNwb25zZS5kYXRhKSB7XG4gICAgICAgIC8vIFRva2VuIGlzIHZhbGlkLCB1cGRhdGUgdXNlciBkYXRhXG4gICAgICAgIGNvbnNvbGUubG9nKCdBdXRoQ29udGV4dDogVG9rZW4gdmVyaWZpZWQgc3VjY2Vzc2Z1bGx5Jyk7XG4gICAgICAgIHNldElzQXV0aGVudGljYXRlZCh0cnVlKTtcbiAgICAgICAgc2V0VXNlcihyZXNwb25zZS5kYXRhLnVzZXIgfHwge30pO1xuICAgICAgICBzZXRUb2tlbih0b2tlbik7IC8vIEVuc3VyZSB0b2tlbiBzdGF0ZSBtYXRjaGVzIHN0b3JhZ2VcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIE5vbi1zdWNjZXNzIEhUVFAgcmVzcG9uc2VcbiAgICAgIGNvbnN0IHN0YXR1cyA9IHJlc3BvbnNlLnN0YXR1c0NvZGUgPz8gMDtcbiAgICAgIGlmIChzdGF0dXMgPT09IDQwMSB8fCBzdGF0dXMgPT09IDQwMykge1xuICAgICAgICBjb25zb2xlLmxvZygnQXV0aENvbnRleHQ6IFRva2VuIHZlcmlmaWNhdGlvbiBmYWlsZWQgd2l0aCB1bmF1dGhvcml6ZWQgc3RhdHVzOicsIHN0YXR1cyk7XG4gICAgICAgIGNsZWFyQXV0aFN0YXRlKCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gRm9yIG90aGVyIGVycm9ycyAoNXh4LCAwLCBldGMuKSwga2VlcCBjdXJyZW50IGF1dGggc3RhdGUgdG8gYXZvaWQgZmxpY2tlclxuICAgICAgY29uc29sZS53YXJuKCdBdXRoQ29udGV4dDogVmVyaWZpY2F0aW9uIG5vbi1zdWNjZXNzIGJ1dCBub3QgdW5hdXRob3JpemVkLiBQcmVzZXJ2aW5nIGF1dGggc3RhdGUuJywge1xuICAgICAgICBzdGF0dXMsXG4gICAgICAgIGVycm9yOiByZXNwb25zZS5lcnJvclxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIE5ldHdvcmsgb3IgdW5leHBlY3RlZCBlcnJvcjogcHJlc2VydmUgY3VycmVudCBhdXRoIHN0YXRlXG4gICAgICBjb25zdCBtc2cgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJztcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1Rva2VuIHZlcmlmaWNhdGlvbiBlcnJvciwgcHJlc2VydmluZyBhdXRoIHN0YXRlOicsIG1zZyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICAvLyBFbmhhbmNlZCBsb2dnaW5nIHV0aWxpdHkgZm9yIGF1dGhlbnRpY2F0aW9uIGV2ZW50c1xuICBjb25zdCBsb2dBdXRoRXZlbnQgPSAoZXZlbnRUeXBlOiBzdHJpbmcsIGRldGFpbHM6IGFueSA9IHt9KSA9PiB7XG4gICAgY29uc3QgdGltZXN0YW1wID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgIGNvbnN0IGxvZ0VudHJ5ID0ge1xuICAgICAgdGltZXN0YW1wLFxuICAgICAgZXZlbnRUeXBlLFxuICAgICAgLi4uZGV0YWlsc1xuICAgIH07XG4gICAgXG4gICAgLy8gT3B0aW9uYWw6IFNlbmQgdG8gYmFja2VuZCBsb2dnaW5nIHNlcnZpY2Ugb3Igc3RvcmUgbG9jYWxseVxuICAgIGNvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KGxvZ0VudHJ5KSk7XG4gICAgXG4gICAgLy8gU3RvcmUgaW4gbG9jYWwgc3RvcmFnZSBmb3IgcG90ZW50aWFsIGRlYnVnZ2luZ1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBhdXRoTG9ncyA9IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2F1dGhfbG9ncycpIHx8ICdbXScpO1xuICAgICAgYXV0aExvZ3MucHVzaChsb2dFbnRyeSk7XG4gICAgICAvLyBLZWVwIG9ubHkgbGFzdCA1MCBsb2cgZW50cmllc1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2F1dGhfbG9ncycsIEpTT04uc3RyaW5naWZ5KGF1dGhMb2dzLnNsaWNlKC01MCkpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gbG9nIGF1dGhlbnRpY2F0aW9uIGV2ZW50JywgZSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIENoZWNrIGlmIHVzZXIgaGFzIGEgd2FsbGV0IGFuZCBnZW5lcmF0ZSBvbmUgaWYgbm90IGF2YWlsYWJsZVxuICBjb25zdCBjaGVja0FuZEdlbmVyYXRlV2FsbGV0ID0gYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBTa2lwIGlmIG5vdCBhdXRoZW50aWNhdGVkXG4gICAgICBpZiAoIWlzQXV0aGVudGljYXRlZCB8fCAhdG9rZW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBGaXJzdCBjaGVjayBpZiB3YWxsZXQgYWxyZWFkeSBleGlzdHNcbiAgICAgIGNvbnN0IHdhbGxldFJlc3BvbnNlID0gYXdhaXQgYXBpLmdldChBUElfRU5EUE9JTlRTLldBTExFVC5JTkZPLCB7fSk7XG4gICAgICBcbiAgICAgIC8vIElmIG5vIHdhbGxldCBvciB3YWxsZXQgYWRkcmVzcyBpcyBlbXB0eSwgZ2VuZXJhdGUgYSBuZXcgb25lXG4gICAgICBpZiAoIXdhbGxldFJlc3BvbnNlLnN1Y2Nlc3MgfHwgXG4gICAgICAgICAgIXdhbGxldFJlc3BvbnNlLmRhdGE/LndhbGxldD8ud2FsbGV0X2FkZHJlc3MpIHtcbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKCdObyB3YWxsZXQgZm91bmQgZm9yIHVzZXIsIGdlbmVyYXRpbmcgYSBuZXcgaW50ZXJuYWwgd2FsbGV0Li4uJyk7XG4gICAgICAgIFxuICAgICAgICAvLyBHZW5lcmF0ZSBhIG5ldyB3YWxsZXRcbiAgICAgICAgY29uc3QgZ2VuZXJhdGVSZXNwb25zZSA9IGF3YWl0IGFwaS5wb3N0KEFQSV9FTkRQT0lOVFMuV0FMTEVULkdFTkVSQVRFLCB7fSk7XG4gICAgICAgIFxuICAgICAgICBpZiAoZ2VuZXJhdGVSZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1dhbGxldCBnZW5lcmF0ZWQgc3VjY2Vzc2Z1bGx5OicsIFxuICAgICAgICAgICAgZ2VuZXJhdGVSZXNwb25zZS5kYXRhPy53YWxsZXQ/LndhbGxldF9hZGRyZXNzKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBZb3UgY291bGQgc2V0IHdhbGxldCBpbmZvIGluIHN0YXRlIGhlcmUgaWYgbmVlZGVkXG4gICAgICAgICAgcmV0dXJuIGdlbmVyYXRlUmVzcG9uc2UuZGF0YT8ud2FsbGV0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBnZW5lcmF0ZSB3YWxsZXQ6JywgZ2VuZXJhdGVSZXNwb25zZS5lcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdVc2VyIHdhbGxldCBhbHJlYWR5IGV4aXN0czonLCBcbiAgICAgICAgICB3YWxsZXRSZXNwb25zZS5kYXRhPy53YWxsZXQ/LndhbGxldF9hZGRyZXNzKTtcbiAgICAgICAgcmV0dXJuIHdhbGxldFJlc3BvbnNlLmRhdGE/LndhbGxldDtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY2hlY2tpbmcvZ2VuZXJhdGluZyB3YWxsZXQ6JywgXG4gICAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gSW1wbGVtZW50IHRva2VuIHJlZnJlc2ggZnVuY3Rpb25hbGl0eSB3aXRoIGV4cG9uZW50aWFsIGJhY2tvZmZcbiAgY29uc3QgcmVmcmVzaFRva2VuID0gYXN5bmMgKHJldHJ5Q291bnQgPSAwKTogUHJvbWlzZTxib29sZWFuPiA9PiB7XG4gICAgY29uc3QgTUFYX1JFVFJJRVMgPSAzO1xuICAgIGNvbnN0IEJBU0VfREVMQVkgPSAxMDAwOyAvLyAxIHNlY29uZCBpbml0aWFsIGRlbGF5XG5cbiAgICB0cnkge1xuICAgICAgbG9nQXV0aEV2ZW50KCdUT0tFTl9SRUZSRVNIX0FUVEVNUFQnLCB7IHJldHJ5Q291bnQgfSk7XG5cbiAgICAgIC8vIEV4cG9uZW50aWFsIGJhY2tvZmYgd2l0aCBqaXR0ZXJcbiAgICAgIGlmIChyZXRyeUNvdW50ID4gMCkge1xuICAgICAgICBjb25zdCBkZWxheSA9IEJBU0VfREVMQVkgKiBNYXRoLnBvdygyLCByZXRyeUNvdW50KSAqICgxICsgTWF0aC5yYW5kb20oKSk7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkZWxheSkpO1xuICAgICAgfVxuXG4gICAgICAvLyBVc2UgdGhlIGRlZGljYXRlZCByZWZyZXNoIHRva2VuIGVuZHBvaW50XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5wb3N0PHt0b2tlbjogc3RyaW5nLCB1c2VybmFtZT86IHN0cmluZ30+KEFQSV9FTkRQT0lOVFMuQVVUSC5SRUZSRVNIX1RPS0VOLCB7fSk7XG4gICAgICBcbiAgICAgIGlmICghcmVzcG9uc2Uuc3VjY2VzcyB8fCAhcmVzcG9uc2UuZGF0YT8udG9rZW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUb2tlbiByZWZyZXNoIGZhaWxlZDogSW52YWxpZCByZXNwb25zZScpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCB7IHRva2VuLCB1c2VybmFtZSB9ID0gcmVzcG9uc2UuZGF0YTtcbiAgICAgIFxuICAgICAgLy8gRGV0ZXJtaW5lIHN0b3JhZ2UgdHlwZSBiYXNlZCBvbiB3aGVyZSB0aGUgY3VycmVudCB0b2tlbiBpcyBzdG9yZWRcbiAgICAgIGNvbnN0IGluTG9jYWxTdG9yYWdlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oVE9LRU5fS0VZKSAhPT0gbnVsbDtcbiAgICAgIGNvbnN0IHJlbWVtYmVyTWUgPSBpbkxvY2FsU3RvcmFnZTsgLy8gSWYgaW4gbG9jYWxTdG9yYWdlLCB1c2VyIHdhbnRlZCBwZXJzaXN0ZW50IGxvZ2luXG4gICAgICBcbiAgICAgIC8vIFN0b3JlIHRoZSBuZXcgdG9rZW4gd2l0aCB0aGUgc2FtZSBwcmVmZXJlbmNlXG4gICAgICBhd2FpdCBzdG9yZUF1dGhUb2tlbih0b2tlbiwgcmVtZW1iZXJNZSk7XG4gICAgICBcbiAgICAgIC8vIFVwZGF0ZSBsb2NhbCB0b2tlbiBzdGF0ZVxuICAgICAgc2V0VG9rZW4odG9rZW4pO1xuICAgICAgc2V0SXNBdXRoZW50aWNhdGVkKHRydWUpO1xuICAgICAgXG4gICAgICAvLyBPcHRpb25hbDogVXBkYXRlIHVzZXJuYW1lIGlmIHByb3ZpZGVkXG4gICAgICBpZiAodXNlcm5hbWUpIHtcbiAgICAgICAgc2V0VXNlcihwcmV2VXNlciA9PiAoeyAuLi5wcmV2VXNlciwgdXNlcm5hbWUgfSkpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBsb2dBdXRoRXZlbnQoJ1RPS0VOX1JFRlJFU0hfU1VDQ0VTUycsIHsgdXNlcm5hbWUgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biByZWZyZXNoIGVycm9yJztcbiAgICAgIFxuICAgICAgbG9nQXV0aEV2ZW50KCdUT0tFTl9SRUZSRVNIX0ZBSUxVUkUnLCB7IFxuICAgICAgICBlcnJvck1lc3NhZ2UsIFxuICAgICAgICByZXRyeUNvdW50LFxuICAgICAgICBlcnJvclN0YWNrOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3Iuc3RhY2sgOiB1bmRlZmluZWRcbiAgICAgIH0pO1xuXG4gICAgICAvLyBJbXBsZW1lbnQgcmV0cnkgbWVjaGFuaXNtXG4gICAgICBpZiAocmV0cnlDb3VudCA8IE1BWF9SRVRSSUVTKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgVG9rZW4gcmVmcmVzaCBhdHRlbXB0ICR7cmV0cnlDb3VudCArIDF9IGZhaWxlZC4gUmV0cnlpbmcuLi5gKTtcbiAgICAgICAgcmV0dXJuIHJlZnJlc2hUb2tlbihyZXRyeUNvdW50ICsgMSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEZpbmFsIGZhbGxiYWNrOiBsb2dvdXQgYWZ0ZXIgbWF4IHJldHJpZXNcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1Rva2VuIHJlZnJlc2ggZmFpbGVkIGFmdGVyIG1heGltdW0gcmV0cmllcycpO1xuICAgICAgbG9nb3V0KCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIC8vIExvZ2luIHdpdGggY3JlZGVudGlhbHNcbiAgY29uc3QgbG9naW4gPSBhc3luYyAoZGF0YTogYW55KTogUHJvbWlzZTxib29sZWFuPiA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKCdBdXRoQ29udGV4dDogbG9naW4gZnVuY3Rpb24gY2FsbGVkIHdpdGggZGF0YTonLCBkYXRhKTtcbiAgICAgIC8vIFNvbWUgQVBJIGNsaWVudHMgc2F2ZSB0aGUgdG9rZW4gZGlyZWN0bHkgdG8gc3RvcmFnZSBhbmQgc3RyaXAgaXQgZnJvbSBwYXlsb2FkXG4gICAgICAvLyBGYWxsIGJhY2sgdG8gcmVhZGluZyBmcm9tIHN0b3JhZ2UgaWYgbm90IHByZXNlbnQgb24gdGhlIHJlc3BvbnNlIG9iamVjdFxuICAgICAgaWYgKCFkYXRhLnRva2VuKSB7XG4gICAgICAgIGNvbnN0IHN0b3JlZFRva2VuID0gZ2V0QXV0aFRva2VuKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdBdXRoQ29udGV4dDogdG9rZW4gbWlzc2luZyBpbiBwYXlsb2FkLCB1c2luZyBzdG9yZWQgdG9rZW46JywgISFzdG9yZWRUb2tlbik7XG4gICAgICAgIGlmIChzdG9yZWRUb2tlbikge1xuICAgICAgICAgIGRhdGEudG9rZW4gPSBzdG9yZWRUb2tlbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHRva2VuIGZvdW5kIGluIGxvZ2luIGRhdGEgb3Igc3RvcmFnZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCdBdXRoQ29udGV4dDogUHJvY2Vzc2luZyBsb2dpbiB3aXRoIHRva2VuJyk7XG4gICAgICBcbiAgICAgIC8vIFN0b3JlIHRva2VuIHdpdGggcmVtZW1iZXIgbWUgcHJlZmVyZW5jZSBpZiBwcm92aWRlZFxuICAgICAgY29uc3QgcmVtZW1iZXJNZSA9IGRhdGEucmVtZW1iZXJfbWUgIT09IHVuZGVmaW5lZCA/IGRhdGEucmVtZW1iZXJfbWUgOiB0cnVlOyAvLyBEZWZhdWx0IHRvIHRydWUgZm9yIHBlcnNpc3RlbnQgbG9naW5cbiAgICAgIFxuICAgICAgLy8gU3RvcmUgdG9rZW4gYW5kIHdhaXQgZm9yIGl0IHRvIGNvbXBsZXRlXG4gICAgICBhd2FpdCBzdG9yZUF1dGhUb2tlbihkYXRhLnRva2VuLCByZW1lbWJlck1lKTtcbiAgICAgIGNvbnNvbGUubG9nKCdBdXRoQ29udGV4dDogVG9rZW4gc3RvcmVkIHN1Y2Nlc3NmdWxseScpO1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgYXBwbGljYXRpb24gc3RhdGVcbiAgICAgIHNldFRva2VuKGRhdGEudG9rZW4pOyAvLyBFbnN1cmUgdG9rZW4gc3RhdGUgaXMgc3luY2hyb25pemVkXG4gICAgICBzZXRVc2VyKGRhdGEudXNlciB8fCB7fSk7XG4gICAgICBzZXRJc0F1dGhlbnRpY2F0ZWQodHJ1ZSk7XG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTsgLy8gRW5zdXJlIGxvYWRpbmcgc3RhdGUgaXMgdHVybmVkIG9mZlxuICAgICAgY29uc29sZS5sb2coJ0F1dGhDb250ZXh0OiBTdGF0ZSB1cGRhdGVkIC0gaXNBdXRoZW50aWNhdGVkOiB0cnVlLCB1c2VyOicsIGRhdGEudXNlcik7XG4gICAgICBcbiAgICAgIC8vIENhcHR1cmUgbWluaW1hbCBzZXNzaW9uIGRhdGEgYWZ0ZXIgc3VjY2Vzc2Z1bCBsb2dpblxuICAgICAgaWYgKGRhdGEudXNlcikge1xuICAgICAgICBTZXNzaW9uUGVyc2lzdGVuY2UuY2FwdHVyZVNuYXBzaG90KGRhdGEudXNlciwgZGF0YS50b2tlbik7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFNldCBmbGFnIHRvIHNraXAgbmV4dCB2ZXJpZmljYXRpb24gY3ljbGUgdG8gYXZvaWQgcmFjZSBjb25kaXRpb25cbiAgICAgIHNldFNraXBOZXh0VmVyaWZpY2F0aW9uKHRydWUpO1xuICAgICAgXG4gICAgICAvLyBMb2cgc3VjY2Vzc2Z1bCBsb2dpbiBzdGF0ZSB1cGRhdGVcbiAgICAgIGNvbnNvbGUubG9nKCdBdXRoQ29udGV4dDogTG9naW4gY29tcGxldGUsIGF1dGggc3RhdGUgdXBkYXRlZCcpO1xuICAgICAgXG4gICAgICAvLyBBdXRvbWF0aWNhbGx5IGNoZWNrIGZvciB3YWxsZXQgYW5kIGdlbmVyYXRlIGlmIG5lZWRlZFxuICAgICAgLy8gVGhpcyBlbnN1cmVzIGV2ZXJ5IHVzZXIgaGFzIGEgd2FsbGV0IGF1dG9tYXRpY2FsbHlcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjaGVja0FuZEdlbmVyYXRlV2FsbGV0KCk7XG4gICAgICB9LCA1MDApOyAvLyBTbWFsbCBkZWxheSB0byBlbnN1cmUgYXV0aCBpcyBmdWxseSBlc3RhYmxpc2hlZFxuICAgICAgXG4gICAgICByZXR1cm4gdHJ1ZTsgLy8gU2lnbmFsIHN1Y2Nlc3NmdWwgbG9naW5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignTG9naW4gZmFpbGVkOicsIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InKTtcbiAgICAgIC8vIEVuc3VyZSBhdXRoIHN0YXRlIGlzIHJlc2V0IGlmIGxvZ2luIGZhaWxzXG4gICAgICBjbGVhckF1dGhUb2tlbnMoKTtcbiAgICAgIFNlc3Npb25QZXJzaXN0ZW5jZS5jbGVhclNuYXBzaG90KCk7XG4gICAgICBcbiAgICAgIHNldFRva2VuKG51bGwpO1xuICAgICAgc2V0VXNlcihudWxsKTtcbiAgICAgIHNldElzQXV0aGVudGljYXRlZChmYWxzZSk7XG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIGZhbHNlOyAvLyBTaWduYWwgZmFpbGVkIGxvZ2luXG4gICAgfVxuICB9O1xuXG4gIC8vIENsZWFyIGF1dGggc3RhdGUgLSByZXVzYWJsZSBmdW5jdGlvbiBmb3IgYm90aCBsb2dvdXQgYW5kIGZhaWxlZCBhdXRoXG4gIGNvbnN0IGNsZWFyQXV0aFN0YXRlID0gKCkgPT4ge1xuICAgIGNsZWFyQXV0aFRva2VucygpO1xuICAgIHNldFRva2VuKG51bGwpO1xuICAgIHNldFVzZXIobnVsbCk7XG4gICAgc2V0SXNBdXRoZW50aWNhdGVkKGZhbHNlKTtcbiAgICBTZXNzaW9uUGVyc2lzdGVuY2UuY2xlYXJTbmFwc2hvdCgpO1xuICB9O1xuICBcbiAgLy8gQ2xlYXIgYXV0aCBzdGF0ZVxuICBjb25zdCBsb2dvdXQgPSBhc3luYyAoKSA9PiB7XG4gICAgbG9nQXV0aEV2ZW50KCdsb2dvdXRfaW5pdGlhdGVkJyk7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEF0dGVtcHQgdG8gY2FsbCBsb2dvdXQgZW5kcG9pbnQgaWYgd2UgaGF2ZSBhIHRva2VuXG4gICAgICBpZiAoZ2V0QXV0aFRva2VuKCkpIHtcbiAgICAgICAgYXdhaXQgYXBpLnBvc3QoQVBJX0VORFBPSU5UUy5BVVRILkxPR09VVCwge30pO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkdXJpbmcgbG9nb3V0OicsIGVycm9yKTtcbiAgICAgIC8vIENvbnRpbnVlIHdpdGggbG9nb3V0IHJlZ2FyZGxlc3Mgb2YgQVBJIGVycm9yc1xuICAgIH0gZmluYWxseSB7XG4gICAgICAvLyBBbHdheXMgY2xlYXIgbG9jYWwgc3RhdGUgYW5kIHN0b3JhZ2VcbiAgICAgIGNsZWFyQXV0aFN0YXRlKCk7XG4gICAgICBcbiAgICAgIC8vIExvZyB0aGUgZXZlbnRcbiAgICAgIGxvZ0F1dGhFdmVudCgnbG9nb3V0X2NvbXBsZXRlJyk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPEF1dGhDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt7IFxuICAgICAgdXNlciwgXG4gICAgICBsb2dpbiwgXG4gICAgICBsb2dvdXQsIFxuICAgICAgbG9hZGluZyxcbiAgICAgIHJlZnJlc2hUb2tlbixcbiAgICAgIGlzQXV0aGVudGljYXRlZFxuICAgIH19PlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvQXV0aENvbnRleHQuUHJvdmlkZXI+XG4gICk7XG59XG5cbmV4cG9ydCBjb25zdCB1c2VBdXRoID0gKCk6IEF1dGhDb250ZXh0VHlwZSA9PiB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KEF1dGhDb250ZXh0KTtcbiAgaWYgKCFjb250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1c2VBdXRoIG11c3QgYmUgdXNlZCB3aXRoaW4gYW4gQXV0aFByb3ZpZGVyJyk7XG4gIH1cbiAgcmV0dXJuIGNvbnRleHQ7XG59O1xuIl0sIm5hbWVzIjpbIlJlYWN0IiwiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJ1c2VFZmZlY3QiLCJ1c2VTdGF0ZSIsIkFQSV9FTkRQT0lOVFMiLCJhcGkiLCJoYXNBZG1pbkJ5cGFzcyIsImJ5cGFzc0xvZ2luIiwiZ2V0QXV0aFRva2VuIiwic3RvcmVBdXRoVG9rZW4iLCJjbGVhckF1dGhUb2tlbnMiLCJUT0tFTl9LRVkiLCJUT0tFTl9FWFBJUllfS0VZIiwiUkVGUkVTSF9UT0tFTl9LRVkiLCJUT0tFTl9WRVJJRllfSU5URVJWQUwiLCJTZXNzaW9uUGVyc2lzdGVuY2UiLCJTVE9SQUdFX0tFWSIsImNhcHR1cmVTbmFwc2hvdCIsInVzZXIiLCJ0b2tlbiIsImNsZWFyU25hcHNob3QiLCJzbmFwc2hvdCIsInRpbWVzdGFtcCIsIkRhdGUiLCJub3ciLCJpZCIsInVzZXJuYW1lIiwiZW1haWwiLCJhdXRoZW50aWNhdGVkIiwic2Vzc2lvblN0b3JhZ2UiLCJzZXRJdGVtIiwiSlNPTiIsInN0cmluZ2lmeSIsImVycm9yIiwiY29uc29sZSIsIndhcm4iLCJyZXRyaWV2ZVNuYXBzaG90Iiwic25hcHNob3RTdHIiLCJnZXRJdGVtIiwicGFyc2UiLCJNQVhfQUdFIiwiaXNFeHBpcmVkIiwicmVtb3ZlSXRlbSIsIkF1dGhDb250ZXh0IiwiQXV0aFByb3ZpZGVyIiwiY2hpbGRyZW4iLCJzZXRVc2VyIiwibG9hZGluZyIsInNldExvYWRpbmciLCJpc0F1dGhlbnRpY2F0ZWQiLCJzZXRJc0F1dGhlbnRpY2F0ZWQiLCJzZXRUb2tlbiIsInNraXBOZXh0VmVyaWZpY2F0aW9uIiwic2V0U2tpcE5leHRWZXJpZmljYXRpb24iLCJsb2dpbiIsImlzTW91bnRlZCIsInZlcmlmeU9uTW91bnQiLCJsb2ciLCJ2ZXJpZnlUb2tlbiIsImludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwicmVzcG9uc2UiLCJnZXQiLCJBVVRIIiwiVkVSSUZZX1RPS0VOIiwic3VjY2VzcyIsImRhdGEiLCJzdGF0dXMiLCJzdGF0dXNDb2RlIiwiY2xlYXJBdXRoU3RhdGUiLCJtc2ciLCJFcnJvciIsIm1lc3NhZ2UiLCJsb2dBdXRoRXZlbnQiLCJldmVudFR5cGUiLCJkZXRhaWxzIiwidG9JU09TdHJpbmciLCJsb2dFbnRyeSIsImF1dGhMb2dzIiwibG9jYWxTdG9yYWdlIiwicHVzaCIsInNsaWNlIiwiZSIsImNoZWNrQW5kR2VuZXJhdGVXYWxsZXQiLCJ3YWxsZXRSZXNwb25zZSIsIldBTExFVCIsIklORk8iLCJ3YWxsZXQiLCJ3YWxsZXRfYWRkcmVzcyIsImdlbmVyYXRlUmVzcG9uc2UiLCJwb3N0IiwiR0VORVJBVEUiLCJyZWZyZXNoVG9rZW4iLCJyZXRyeUNvdW50IiwiTUFYX1JFVFJJRVMiLCJCQVNFX0RFTEFZIiwiZGVsYXkiLCJNYXRoIiwicG93IiwicmFuZG9tIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiUkVGUkVTSF9UT0tFTiIsImluTG9jYWxTdG9yYWdlIiwicmVtZW1iZXJNZSIsInByZXZVc2VyIiwiZXJyb3JNZXNzYWdlIiwiZXJyb3JTdGFjayIsInN0YWNrIiwidW5kZWZpbmVkIiwibG9nb3V0Iiwic3RvcmVkVG9rZW4iLCJyZW1lbWJlcl9tZSIsIkxPR09VVCIsIlByb3ZpZGVyIiwidmFsdWUiLCJ1c2VBdXRoIiwiY29udGV4dCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/AuthContext.tsx\n"));

/***/ })

});