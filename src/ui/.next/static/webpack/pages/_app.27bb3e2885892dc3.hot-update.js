"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "(pages-dir-browser)/./components/AuthContext.tsx":
/*!************************************!*\
  !*** ./components/AuthContext.tsx ***!
  \************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthProvider: () => (/* binding */ AuthProvider),\n/* harmony export */   useAuth: () => (/* binding */ useAuth)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/.pnpm/react@19.1.1/node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/.pnpm/react@19.1.1/node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _api_apiClient__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../api/apiClient */ \"(pages-dir-browser)/./api/apiClient.ts\");\n/* harmony import */ var _utils_devAuth__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/devAuth */ \"(pages-dir-browser)/./utils/devAuth.ts\");\n/* harmony import */ var _utils_authUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/authUtils */ \"(pages-dir-browser)/./utils/authUtils.ts\");\n// src/ui/components/AuthContext.tsx\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\n// Import admin backdoor utilities\n\n// Import standardized auth utils\n\nconst TOKEN_EXPIRY_KEY = 'grace_token_expiry';\nconst REFRESH_TOKEN_KEY = 'grace_refresh_token';\nconst TOKEN_VERIFY_INTERVAL = 60000; // Check token validity every 60 seconds\n// Improved session persistence utility to avoid conflicts with form state\nconst SessionPersistence = {\n    STORAGE_KEY: 'GRACE_SESSION_SNAPSHOT',\n    // Safely capture session snapshot with minimal data to avoid interference\n    captureSnapshot (user, token) {\n        try {\n            if (!user || !token) {\n                this.clearSnapshot();\n                return;\n            }\n            // Store only essential user identification data\n            // Avoid storing complete state that might conflict with forms\n            const snapshot = {\n                timestamp: Date.now(),\n                user: {\n                    id: user.id,\n                    username: user.username,\n                    email: user.email\n                },\n                // Don't store the actual token, just indicate authentication\n                authenticated: true\n            };\n            // Use sessionStorage instead of localStorage to avoid persisting between browser sessions\n            // This helps prevent stale data from affecting forms on future visits\n            sessionStorage.setItem(this.STORAGE_KEY, JSON.stringify(snapshot));\n        } catch (error) {\n            console.warn('Failed to capture session snapshot', error);\n        // Silently fail - don't let snapshot errors affect the application\n        }\n    },\n    // Retrieve session snapshot with validation\n    retrieveSnapshot () {\n        try {\n            const snapshotStr = sessionStorage.getItem(this.STORAGE_KEY);\n            if (!snapshotStr) return {\n                user: null,\n                token: null\n            };\n            const snapshot = JSON.parse(snapshotStr);\n            // Validate snapshot with expiration check (30 minutes)\n            const MAX_AGE = 30 * 60 * 1000; // 30 minutes in milliseconds\n            const isExpired = Date.now() - (snapshot.timestamp || 0) > MAX_AGE;\n            if (snapshot && snapshot.user && !isExpired) {\n                return {\n                    user: snapshot.user,\n                    // Get actual token from authUtils to ensure consistency\n                    token: (0,_utils_authUtils__WEBPACK_IMPORTED_MODULE_4__.getAuthToken)()\n                };\n            }\n            // Clear expired snapshot\n            if (isExpired) this.clearSnapshot();\n            return {\n                user: null,\n                token: null\n            };\n        } catch (error) {\n            console.warn('Failed to retrieve session snapshot', error);\n            this.clearSnapshot(); // Clear invalid snapshot\n            return {\n                user: null,\n                token: null\n            };\n        }\n    },\n    // Clear session snapshot\n    clearSnapshot () {\n        try {\n            sessionStorage.removeItem(this.STORAGE_KEY);\n        } catch (error) {\n            console.warn('Failed to clear session snapshot', error);\n        }\n    }\n};\nconst AuthContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\nfunction AuthProvider(param) {\n    let { children } = param;\n    _s();\n    const [user, setUser] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [isAuthenticated, setIsAuthenticated] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Use state for token to ensure it's updated when changed\n    const [token, setToken] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)((0,_utils_authUtils__WEBPACK_IMPORTED_MODULE_4__.getAuthToken)());\n    // Add flag to prevent verification immediately after login\n    const [skipNextVerification, setSkipNextVerification] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Update token state whenever auth state changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"AuthProvider.useEffect\": ()=>{\n            setToken((0,_utils_authUtils__WEBPACK_IMPORTED_MODULE_4__.getAuthToken)());\n        }\n    }[\"AuthProvider.useEffect\"], [\n        isAuthenticated\n    ]);\n    // Admin backdoor for quick access\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"AuthProvider.useEffect\": ()=>{\n            // Check if we should use the admin backdoor\n            if ((0,_utils_devAuth__WEBPACK_IMPORTED_MODULE_3__.hasAdminBypass)() && !isAuthenticated && !token) {\n                (0,_utils_devAuth__WEBPACK_IMPORTED_MODULE_3__.bypassLogin)(login);\n            }\n        }\n    }[\"AuthProvider.useEffect\"], []);\n    // FIXED: Stabilized verification on mount and periodic checks\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"AuthProvider.useEffect\": ()=>{\n            let isMounted = true;\n            const verifyOnMount = {\n                \"AuthProvider.useEffect.verifyOnMount\": async ()=>{\n                    // Skip initial verification if there's no token\n                    if ( true && !(0,_utils_authUtils__WEBPACK_IMPORTED_MODULE_4__.getAuthToken)()) {\n                        console.log('AuthContext: No token found on mount, skipping verification');\n                        if (isMounted) setLoading(false);\n                        return;\n                    }\n                    console.log('AuthContext: Verifying token on mount');\n                    // Verify token on component mount (force = true to bypass debouncing)\n                    await verifyToken(true);\n                    // Handle case where verification completed but component was unmounted\n                    if (isMounted) setLoading(false);\n                }\n            }[\"AuthProvider.useEffect.verifyOnMount\"];\n            verifyOnMount();\n            // FIXED: Increased interval to reduce verification frequency\n            const interval = setInterval({\n                \"AuthProvider.useEffect.interval\": ()=>{\n                    if (!skipNextVerification) {\n                        verifyToken(); // Use debounced version for periodic checks\n                    } else {\n                        // Reset skip flag after using it once\n                        setSkipNextVerification(false);\n                    }\n                }\n            }[\"AuthProvider.useEffect.interval\"], 120000); // FIXED: Increased to 2 minutes to reduce server load\n            return ({\n                \"AuthProvider.useEffect\": ()=>{\n                    isMounted = false;\n                    clearInterval(interval);\n                }\n            })[\"AuthProvider.useEffect\"];\n        }\n    }[\"AuthProvider.useEffect\"], []);\n    // FIXED: Add debouncing to prevent rapid verification calls\n    const verifyTokenDebounced = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const lastVerifyAttempt = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n    // Verify user token with backend (FIXED: Added debouncing and better error handling)\n    const verifyToken = async function() {\n        let force = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;\n        // If no token exists, there's nothing to verify\n        const token = (0,_utils_authUtils__WEBPACK_IMPORTED_MODULE_4__.getAuthToken)();\n        if (!token) {\n            console.log('AuthContext: No token to verify');\n            setIsAuthenticated(false);\n            setUser(null);\n            setLoading(false);\n            return false;\n        }\n        // FIXED: Debounce verification calls to prevent rapid requests\n        const now = Date.now();\n        if (!force && now - lastVerifyAttempt.current < 5000) {\n            console.log('AuthContext: Skipping verification (debounced)');\n            return false;\n        }\n        lastVerifyAttempt.current = now;\n        try {\n            console.log('AuthContext: Verifying token with backend');\n            setLoading(true);\n            const response = await _api_apiClient__WEBPACK_IMPORTED_MODULE_2__[\"default\"].get(_api_apiClient__WEBPACK_IMPORTED_MODULE_2__.API_ENDPOINTS.AUTH.VERIFY_TOKEN);\n            if (response.success && response.data) {\n                // Token is valid, update user data\n                console.log('AuthContext: Token verified successfully');\n                setIsAuthenticated(true);\n                setUser(response.data.user || {});\n                setToken(token); // Ensure token state matches storage\n                return true;\n            }\n            var _response_statusCode;\n            // Non-success HTTP response\n            const status = (_response_statusCode = response.statusCode) !== null && _response_statusCode !== void 0 ? _response_statusCode : 0;\n            if (status === 401 || status === 403) {\n                console.log('AuthContext: Token verification failed with unauthorized status:', status);\n                clearAuthState();\n                return false;\n            }\n            // FIXED: For other errors (5xx, 0, etc.), keep current auth state to avoid flicker\n            console.warn('AuthContext: Verification non-success but not unauthorized. Preserving auth state.', {\n                status,\n                error: response.error\n            });\n            return false;\n        } catch (error) {\n            // FIXED: Network or unexpected error: preserve current auth state to prevent bouncing\n            const msg = error instanceof Error ? error.message : 'Unknown error';\n            console.error('Token verification error, preserving auth state:', msg);\n            return false;\n        } finally{\n            setLoading(false);\n        }\n    };\n    // Enhanced logging utility for authentication events\n    const logAuthEvent = function(eventType) {\n        let details = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        const timestamp = new Date().toISOString();\n        const logEntry = {\n            timestamp,\n            eventType,\n            ...details\n        };\n        // Optional: Send to backend logging service or store locally\n        console.log(JSON.stringify(logEntry));\n        // Store in local storage for potential debugging\n        try {\n            const authLogs = JSON.parse(localStorage.getItem('auth_logs') || '[]');\n            authLogs.push(logEntry);\n            // Keep only last 50 log entries\n            localStorage.setItem('auth_logs', JSON.stringify(authLogs.slice(-50)));\n        } catch (e) {\n            console.error('Failed to log authentication event', e);\n        }\n    };\n    // Check if user has a wallet and generate one if not available\n    const checkAndGenerateWallet = async ()=>{\n        try {\n            var _walletResponse_data_wallet, _walletResponse_data;\n            // Skip if not authenticated\n            if (!isAuthenticated || !token) {\n                return;\n            }\n            // First check if wallet already exists\n            const walletResponse = await _api_apiClient__WEBPACK_IMPORTED_MODULE_2__[\"default\"].get(_api_apiClient__WEBPACK_IMPORTED_MODULE_2__.API_ENDPOINTS.WALLET.INFO, {});\n            // If no wallet or wallet address is empty, generate a new one\n            if (!walletResponse.success || !((_walletResponse_data = walletResponse.data) === null || _walletResponse_data === void 0 ? void 0 : (_walletResponse_data_wallet = _walletResponse_data.wallet) === null || _walletResponse_data_wallet === void 0 ? void 0 : _walletResponse_data_wallet.wallet_address)) {\n                console.log('No wallet found for user, generating a new internal wallet...');\n                // Generate a new wallet\n                const generateResponse = await _api_apiClient__WEBPACK_IMPORTED_MODULE_2__[\"default\"].post(_api_apiClient__WEBPACK_IMPORTED_MODULE_2__.API_ENDPOINTS.WALLET.GENERATE, {});\n                if (generateResponse.success) {\n                    var _generateResponse_data_wallet, _generateResponse_data, _generateResponse_data1;\n                    console.log('Wallet generated successfully:', (_generateResponse_data = generateResponse.data) === null || _generateResponse_data === void 0 ? void 0 : (_generateResponse_data_wallet = _generateResponse_data.wallet) === null || _generateResponse_data_wallet === void 0 ? void 0 : _generateResponse_data_wallet.wallet_address);\n                    // You could set wallet info in state here if needed\n                    return (_generateResponse_data1 = generateResponse.data) === null || _generateResponse_data1 === void 0 ? void 0 : _generateResponse_data1.wallet;\n                } else {\n                    console.error('Failed to generate wallet:', generateResponse.error);\n                }\n            } else {\n                var _walletResponse_data_wallet1, _walletResponse_data1, _walletResponse_data2;\n                console.log('User wallet already exists:', (_walletResponse_data1 = walletResponse.data) === null || _walletResponse_data1 === void 0 ? void 0 : (_walletResponse_data_wallet1 = _walletResponse_data1.wallet) === null || _walletResponse_data_wallet1 === void 0 ? void 0 : _walletResponse_data_wallet1.wallet_address);\n                return (_walletResponse_data2 = walletResponse.data) === null || _walletResponse_data2 === void 0 ? void 0 : _walletResponse_data2.wallet;\n            }\n        } catch (error) {\n            console.error('Error checking/generating wallet:', error instanceof Error ? error.message : 'Unknown error');\n        }\n    };\n    // Implement token refresh functionality with exponential backoff\n    const refreshToken = async function() {\n        let retryCount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;\n        const MAX_RETRIES = 3;\n        const BASE_DELAY = 1000; // 1 second initial delay\n        try {\n            var _response_data;\n            logAuthEvent('TOKEN_REFRESH_ATTEMPT', {\n                retryCount\n            });\n            // Exponential backoff with jitter\n            if (retryCount > 0) {\n                const delay = BASE_DELAY * Math.pow(2, retryCount) * (1 + Math.random());\n                await new Promise((resolve)=>setTimeout(resolve, delay));\n            }\n            // Use the dedicated refresh token endpoint\n            const response = await _api_apiClient__WEBPACK_IMPORTED_MODULE_2__[\"default\"].post(_api_apiClient__WEBPACK_IMPORTED_MODULE_2__.API_ENDPOINTS.AUTH.REFRESH_TOKEN, {});\n            if (!response.success || !((_response_data = response.data) === null || _response_data === void 0 ? void 0 : _response_data.token)) {\n                throw new Error('Token refresh failed: Invalid response');\n            }\n            const { token, username } = response.data;\n            // Determine storage type based on where the current token is stored\n            const inLocalStorage = localStorage.getItem(_utils_authUtils__WEBPACK_IMPORTED_MODULE_4__.TOKEN_KEY) !== null;\n            const rememberMe = inLocalStorage; // If in localStorage, user wanted persistent login\n            // Store the new token with the same preference\n            await (0,_utils_authUtils__WEBPACK_IMPORTED_MODULE_4__.storeAuthToken)(token, rememberMe);\n            // Update local token state\n            setToken(token);\n            setIsAuthenticated(true);\n            // Optional: Update username if provided\n            if (username) {\n                setUser((prevUser)=>({\n                        ...prevUser,\n                        username\n                    }));\n            }\n            logAuthEvent('TOKEN_REFRESH_SUCCESS', {\n                username\n            });\n            return true;\n        } catch (error) {\n            const errorMessage = error instanceof Error ? error.message : 'Unknown refresh error';\n            logAuthEvent('TOKEN_REFRESH_FAILURE', {\n                errorMessage,\n                retryCount,\n                errorStack: error instanceof Error ? error.stack : undefined\n            });\n            // Implement retry mechanism\n            if (retryCount < MAX_RETRIES) {\n                console.warn(\"Token refresh attempt \".concat(retryCount + 1, \" failed. Retrying...\"));\n                return refreshToken(retryCount + 1);\n            }\n            // Final fallback: logout after max retries\n            console.error('Token refresh failed after maximum retries');\n            logout();\n            return false;\n        }\n    };\n    // Login with credentials\n    const login = async (data)=>{\n        try {\n            console.log('AuthContext: login function called with data:', data);\n            // Some API clients save the token directly to storage and strip it from payload\n            // Fall back to reading from storage if not present on the response object\n            if (!data.token) {\n                const storedToken = (0,_utils_authUtils__WEBPACK_IMPORTED_MODULE_4__.getAuthToken)();\n                console.log('AuthContext: token missing in payload, using stored token:', !!storedToken);\n                if (storedToken) {\n                    data.token = storedToken;\n                } else {\n                    throw new Error('No token found in login data or storage');\n                }\n            }\n            console.log('AuthContext: Processing login with token');\n            // Store token with remember me preference if provided\n            const rememberMe = data.remember_me !== undefined ? data.remember_me : true; // Default to true for persistent login\n            // Store token and wait for it to complete\n            await (0,_utils_authUtils__WEBPACK_IMPORTED_MODULE_4__.storeAuthToken)(data.token, rememberMe);\n            console.log('AuthContext: Token stored successfully');\n            // Update application state\n            setToken(data.token); // Ensure token state is synchronized\n            setUser(data.user || {});\n            setIsAuthenticated(true);\n            setLoading(false); // Ensure loading state is turned off\n            console.log('AuthContext: State updated - isAuthenticated: true, user:', data.user);\n            // Capture minimal session data after successful login\n            if (data.user) {\n                SessionPersistence.captureSnapshot(data.user, data.token);\n            }\n            // Set flag to skip next verification cycle to avoid race condition\n            setSkipNextVerification(true);\n            // Log successful login state update\n            console.log('AuthContext: Login complete, auth state updated');\n            // Automatically check for wallet and generate if needed\n            // This ensures every user has a wallet automatically\n            setTimeout(()=>{\n                checkAndGenerateWallet();\n            }, 500); // Small delay to ensure auth is fully established\n            return true; // Signal successful login\n        } catch (error) {\n            console.error('Login failed:', error instanceof Error ? error.message : 'Unknown error');\n            // Ensure auth state is reset if login fails\n            (0,_utils_authUtils__WEBPACK_IMPORTED_MODULE_4__.clearAuthTokens)();\n            SessionPersistence.clearSnapshot();\n            setToken(null);\n            setUser(null);\n            setIsAuthenticated(false);\n            setLoading(false);\n            return false; // Signal failed login\n        }\n    };\n    // Clear auth state - reusable function for both logout and failed auth\n    const clearAuthState = ()=>{\n        (0,_utils_authUtils__WEBPACK_IMPORTED_MODULE_4__.clearAuthTokens)();\n        setToken(null);\n        setUser(null);\n        setIsAuthenticated(false);\n        SessionPersistence.clearSnapshot();\n    };\n    // Clear auth state\n    const logout = async ()=>{\n        logAuthEvent('logout_initiated');\n        try {\n            // Attempt to call logout endpoint if we have a token\n            if ((0,_utils_authUtils__WEBPACK_IMPORTED_MODULE_4__.getAuthToken)()) {\n                await _api_apiClient__WEBPACK_IMPORTED_MODULE_2__[\"default\"].post(_api_apiClient__WEBPACK_IMPORTED_MODULE_2__.API_ENDPOINTS.AUTH.LOGOUT, {});\n            }\n        } catch (error) {\n            console.error('Error during logout:', error);\n        // Continue with logout regardless of API errors\n        } finally{\n            // Always clear local state and storage\n            clearAuthState();\n            // Log the event\n            logAuthEvent('logout_complete');\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(AuthContext.Provider, {\n        value: {\n            user,\n            login,\n            logout,\n            loading,\n            refreshToken,\n            isAuthenticated\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"/home/ubuntu/grace-project/src/ui/components/AuthContext.tsx\",\n        lineNumber: 459,\n        columnNumber: 5\n    }, this);\n}\n_s(AuthProvider, \"Io4Wtsgbyrs7EWbL7rz99kPX1nI=\");\n_c = AuthProvider;\nconst useAuth = ()=>{\n    _s1();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(AuthContext);\n    if (!context) {\n        throw new Error('useAuth must be used within an AuthProvider');\n    }\n    return context;\n};\n_s1(useAuth, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"AuthProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvQXV0aENvbnRleHQudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBLG9DQUFvQzs7O0FBRWtEO0FBQ3JDO0FBQ2Q7QUFDbkMsa0NBQWtDO0FBQzZCO0FBQy9ELGlDQUFpQztBQVNMO0FBRTVCLE1BQU1jLG1CQUFtQjtBQUN6QixNQUFNQyxvQkFBb0I7QUFDMUIsTUFBTUMsd0JBQXdCLE9BQU8sd0NBQXdDO0FBRTdFLDBFQUEwRTtBQUMxRSxNQUFNQyxxQkFBcUI7SUFDekJDLGFBQWE7SUFFYiwwRUFBMEU7SUFDMUVDLGlCQUFnQkMsSUFBaUIsRUFBRUMsS0FBb0I7UUFDckQsSUFBSTtZQUNGLElBQUksQ0FBQ0QsUUFBUSxDQUFDQyxPQUFPO2dCQUNuQixJQUFJLENBQUNDLGFBQWE7Z0JBQ2xCO1lBQ0Y7WUFFQSxnREFBZ0Q7WUFDaEQsOERBQThEO1lBQzlELE1BQU1DLFdBQVc7Z0JBQ2ZDLFdBQVdDLEtBQUtDLEdBQUc7Z0JBQ25CTixNQUFNO29CQUNKTyxJQUFJUCxLQUFLTyxFQUFFO29CQUNYQyxVQUFVUixLQUFLUSxRQUFRO29CQUN2QkMsT0FBT1QsS0FBS1MsS0FBSztnQkFDbkI7Z0JBQ0EsNkRBQTZEO2dCQUM3REMsZUFBZTtZQUNqQjtZQUVBLDBGQUEwRjtZQUMxRixzRUFBc0U7WUFDdEVDLGVBQWVDLE9BQU8sQ0FBQyxJQUFJLENBQUNkLFdBQVcsRUFBRWUsS0FBS0MsU0FBUyxDQUFDWDtRQUMxRCxFQUFFLE9BQU9ZLE9BQU87WUFDZEMsUUFBUUMsSUFBSSxDQUFDLHNDQUFzQ0Y7UUFDbkQsbUVBQW1FO1FBQ3JFO0lBQ0Y7SUFFQSw0Q0FBNEM7SUFDNUNHO1FBQ0UsSUFBSTtZQUNGLE1BQU1DLGNBQWNSLGVBQWVTLE9BQU8sQ0FBQyxJQUFJLENBQUN0QixXQUFXO1lBQzNELElBQUksQ0FBQ3FCLGFBQWEsT0FBTztnQkFBRW5CLE1BQU07Z0JBQU1DLE9BQU87WUFBSztZQUVuRCxNQUFNRSxXQUFXVSxLQUFLUSxLQUFLLENBQUNGO1lBRTVCLHVEQUF1RDtZQUN2RCxNQUFNRyxVQUFVLEtBQUssS0FBSyxNQUFNLDZCQUE2QjtZQUM3RCxNQUFNQyxZQUFZLEtBQU1qQixHQUFHLEtBQU1ILENBQUFBLFNBQVNDLFNBQVMsSUFBSSxLQUFNa0I7WUFFN0QsSUFBSW5CLFlBQVlBLFNBQVNILElBQUksSUFBSSxDQUFDdUIsV0FBVztnQkFDM0MsT0FBTztvQkFDTHZCLE1BQU1HLFNBQVNILElBQUk7b0JBQ25CLHdEQUF3RDtvQkFDeERDLE9BQU9YLDhEQUFZQTtnQkFDckI7WUFDRjtZQUVBLHlCQUF5QjtZQUN6QixJQUFJaUMsV0FBVyxJQUFJLENBQUNyQixhQUFhO1lBQ2pDLE9BQU87Z0JBQUVGLE1BQU07Z0JBQU1DLE9BQU87WUFBSztRQUNuQyxFQUFFLE9BQU9jLE9BQU87WUFDZEMsUUFBUUMsSUFBSSxDQUFDLHVDQUF1Q0Y7WUFDcEQsSUFBSSxDQUFDYixhQUFhLElBQUkseUJBQXlCO1lBQy9DLE9BQU87Z0JBQUVGLE1BQU07Z0JBQU1DLE9BQU87WUFBSztRQUNuQztJQUNGO0lBRUEseUJBQXlCO0lBQ3pCQztRQUNFLElBQUk7WUFDRlMsZUFBZWEsVUFBVSxDQUFDLElBQUksQ0FBQzFCLFdBQVc7UUFDNUMsRUFBRSxPQUFPaUIsT0FBTztZQUNkQyxRQUFRQyxJQUFJLENBQUMsb0NBQW9DRjtRQUNuRDtJQUNGO0FBQ0Y7QUFrQkEsTUFBTVUsNEJBQWM1QyxvREFBYUEsQ0FBeUI7QUFHbkQsU0FBUzZDLGFBQWEsS0FBMkM7UUFBM0MsRUFBRUMsUUFBUSxFQUFpQyxHQUEzQzs7SUFDM0IsTUFBTSxDQUFDM0IsTUFBTTRCLFFBQVEsR0FBRzVDLCtDQUFRQSxDQUFjO0lBQzlDLE1BQU0sQ0FBQzZDLFNBQVNDLFdBQVcsR0FBRzlDLCtDQUFRQSxDQUFVO0lBQ2hELE1BQU0sQ0FBQytDLGlCQUFpQkMsbUJBQW1CLEdBQUdoRCwrQ0FBUUEsQ0FBVTtJQUNoRSwwREFBMEQ7SUFDMUQsTUFBTSxDQUFDaUIsT0FBT2dDLFNBQVMsR0FBR2pELCtDQUFRQSxDQUFnQk0sOERBQVlBO0lBQzlELDJEQUEyRDtJQUMzRCxNQUFNLENBQUM0QyxzQkFBc0JDLHdCQUF3QixHQUFHbkQsK0NBQVFBLENBQVU7SUFFMUUsaURBQWlEO0lBQ2pERCxnREFBU0E7a0NBQUM7WUFDUmtELFNBQVMzQyw4REFBWUE7UUFDdkI7aUNBQUc7UUFBQ3lDO0tBQWdCO0lBRXBCLGtDQUFrQztJQUNsQ2hELGdEQUFTQTtrQ0FBQztZQUNSLDRDQUE0QztZQUM1QyxJQUFJSyw4REFBY0EsTUFBTSxDQUFDMkMsbUJBQW1CLENBQUM5QixPQUFPO2dCQUNsRFosMkRBQVdBLENBQUMrQztZQUNkO1FBQ0Y7aUNBQUcsRUFBRTtJQUVMLDhEQUE4RDtJQUM5RHJELGdEQUFTQTtrQ0FBQztZQUNSLElBQUlzRCxZQUFZO1lBRWhCLE1BQU1DO3dEQUFnQjtvQkFDcEIsZ0RBQWdEO29CQUNoRCxJQUFJLEtBQTZCLElBQUksQ0FBQ2hELDhEQUFZQSxJQUFJO3dCQUNwRDBCLFFBQVF1QixHQUFHLENBQUM7d0JBQ1osSUFBSUYsV0FBV1AsV0FBVzt3QkFDMUI7b0JBQ0Y7b0JBRUFkLFFBQVF1QixHQUFHLENBQUM7b0JBQ1osc0VBQXNFO29CQUN0RSxNQUFNQyxZQUFZO29CQUVsQix1RUFBdUU7b0JBQ3ZFLElBQUlILFdBQVdQLFdBQVc7Z0JBQzVCOztZQUVBUTtZQUVBLDZEQUE2RDtZQUM3RCxNQUFNRyxXQUFXQzttREFBWTtvQkFDM0IsSUFBSSxDQUFDUixzQkFBc0I7d0JBQ3pCTSxlQUFlLDRDQUE0QztvQkFDN0QsT0FBTzt3QkFDTCxzQ0FBc0M7d0JBQ3RDTCx3QkFBd0I7b0JBQzFCO2dCQUNGO2tEQUFHLFNBQVMsc0RBQXNEO1lBRWxFOzBDQUFPO29CQUNMRSxZQUFZO29CQUNaTSxjQUFjRjtnQkFDaEI7O1FBQ0Y7aUNBQUcsRUFBRTtJQUVMLDREQUE0RDtJQUM1RCxNQUFNRyx1QkFBdUIzRCw2Q0FBTUEsQ0FBd0I7SUFDM0QsTUFBTTRELG9CQUFvQjVELDZDQUFNQSxDQUFTO0lBRXpDLHFGQUFxRjtJQUNyRixNQUFNdUQsY0FBYztZQUFPTSx5RUFBaUI7UUFDMUMsZ0RBQWdEO1FBQ2hELE1BQU03QyxRQUFRWCw4REFBWUE7UUFDMUIsSUFBSSxDQUFDVyxPQUFPO1lBQ1ZlLFFBQVF1QixHQUFHLENBQUM7WUFDWlAsbUJBQW1CO1lBQ25CSixRQUFRO1lBQ1JFLFdBQVc7WUFDWCxPQUFPO1FBQ1Q7UUFFQSwrREFBK0Q7UUFDL0QsTUFBTXhCLE1BQU1ELEtBQUtDLEdBQUc7UUFDcEIsSUFBSSxDQUFDd0MsU0FBU3hDLE1BQU11QyxrQkFBa0JFLE9BQU8sR0FBRyxNQUFNO1lBQ3BEL0IsUUFBUXVCLEdBQUcsQ0FBQztZQUNaLE9BQU87UUFDVDtRQUNBTSxrQkFBa0JFLE9BQU8sR0FBR3pDO1FBRTVCLElBQUk7WUFDRlUsUUFBUXVCLEdBQUcsQ0FBQztZQUNaVCxXQUFXO1lBQ1gsTUFBTWtCLFdBQVcsTUFBTTdELDBEQUFPLENBQUNELHlEQUFhQSxDQUFDZ0UsSUFBSSxDQUFDQyxZQUFZO1lBRTlELElBQUlILFNBQVNJLE9BQU8sSUFBSUosU0FBU0ssSUFBSSxFQUFFO2dCQUNyQyxtQ0FBbUM7Z0JBQ25DckMsUUFBUXVCLEdBQUcsQ0FBQztnQkFDWlAsbUJBQW1CO2dCQUNuQkosUUFBUW9CLFNBQVNLLElBQUksQ0FBQ3JELElBQUksSUFBSSxDQUFDO2dCQUMvQmlDLFNBQVNoQyxRQUFRLHFDQUFxQztnQkFDdEQsT0FBTztZQUNUO2dCQUdlK0M7WUFEZiw0QkFBNEI7WUFDNUIsTUFBTU0sU0FBU04sQ0FBQUEsdUJBQUFBLFNBQVNPLFVBQVUsY0FBbkJQLGtDQUFBQSx1QkFBdUI7WUFDdEMsSUFBSU0sV0FBVyxPQUFPQSxXQUFXLEtBQUs7Z0JBQ3BDdEMsUUFBUXVCLEdBQUcsQ0FBQyxvRUFBb0VlO2dCQUNoRkU7Z0JBQ0EsT0FBTztZQUNUO1lBRUEsbUZBQW1GO1lBQ25GeEMsUUFBUUMsSUFBSSxDQUFDLHNGQUFzRjtnQkFDakdxQztnQkFDQXZDLE9BQU9pQyxTQUFTakMsS0FBSztZQUN2QjtZQUNBLE9BQU87UUFDVCxFQUFFLE9BQU9BLE9BQU87WUFDZCxzRkFBc0Y7WUFDdEYsTUFBTTBDLE1BQU0xQyxpQkFBaUIyQyxRQUFRM0MsTUFBTTRDLE9BQU8sR0FBRztZQUNyRDNDLFFBQVFELEtBQUssQ0FBQyxvREFBb0QwQztZQUNsRSxPQUFPO1FBQ1QsU0FBVTtZQUNSM0IsV0FBVztRQUNiO0lBQ0Y7SUFFQSxxREFBcUQ7SUFDckQsTUFBTThCLGVBQWUsU0FBQ0M7WUFBbUJDLDJFQUFlLENBQUM7UUFDdkQsTUFBTTFELFlBQVksSUFBSUMsT0FBTzBELFdBQVc7UUFDeEMsTUFBTUMsV0FBVztZQUNmNUQ7WUFDQXlEO1lBQ0EsR0FBR0MsT0FBTztRQUNaO1FBRUEsNkRBQTZEO1FBQzdEOUMsUUFBUXVCLEdBQUcsQ0FBQzFCLEtBQUtDLFNBQVMsQ0FBQ2tEO1FBRTNCLGlEQUFpRDtRQUNqRCxJQUFJO1lBQ0YsTUFBTUMsV0FBV3BELEtBQUtRLEtBQUssQ0FBQzZDLGFBQWE5QyxPQUFPLENBQUMsZ0JBQWdCO1lBQ2pFNkMsU0FBU0UsSUFBSSxDQUFDSDtZQUNkLGdDQUFnQztZQUNoQ0UsYUFBYXRELE9BQU8sQ0FBQyxhQUFhQyxLQUFLQyxTQUFTLENBQUNtRCxTQUFTRyxLQUFLLENBQUMsQ0FBQztRQUNuRSxFQUFFLE9BQU9DLEdBQUc7WUFDVnJELFFBQVFELEtBQUssQ0FBQyxzQ0FBc0NzRDtRQUN0RDtJQUNGO0lBRUEsK0RBQStEO0lBQy9ELE1BQU1DLHlCQUF5QjtRQUM3QixJQUFJO2dCQVdHQyw2QkFBQUE7WUFWTCw0QkFBNEI7WUFDNUIsSUFBSSxDQUFDeEMsbUJBQW1CLENBQUM5QixPQUFPO2dCQUM5QjtZQUNGO1lBRUEsdUNBQXVDO1lBQ3ZDLE1BQU1zRSxpQkFBaUIsTUFBTXBGLDBEQUFPLENBQUNELHlEQUFhQSxDQUFDc0YsTUFBTSxDQUFDQyxJQUFJLEVBQUUsQ0FBQztZQUVqRSw4REFBOEQ7WUFDOUQsSUFBSSxDQUFDRixlQUFlbkIsT0FBTyxJQUN2QixHQUFDbUIsdUJBQUFBLGVBQWVsQixJQUFJLGNBQW5Ca0IsNENBQUFBLDhCQUFBQSxxQkFBcUJHLE1BQU0sY0FBM0JILGtEQUFBQSw0QkFBNkJJLGNBQWMsR0FBRTtnQkFFaEQzRCxRQUFRdUIsR0FBRyxDQUFDO2dCQUVaLHdCQUF3QjtnQkFDeEIsTUFBTXFDLG1CQUFtQixNQUFNekYsMkRBQVEsQ0FBQ0QseURBQWFBLENBQUNzRixNQUFNLENBQUNNLFFBQVEsRUFBRSxDQUFDO2dCQUV4RSxJQUFJRixpQkFBaUJ4QixPQUFPLEVBQUU7d0JBRTFCd0IsK0JBQUFBLHdCQUdLQTtvQkFKUDVELFFBQVF1QixHQUFHLENBQUMsbUNBQ1ZxQyx5QkFBQUEsaUJBQWlCdkIsSUFBSSxjQUFyQnVCLDhDQUFBQSxnQ0FBQUEsdUJBQXVCRixNQUFNLGNBQTdCRSxvREFBQUEsOEJBQStCRCxjQUFjO29CQUUvQyxvREFBb0Q7b0JBQ3BELFFBQU9DLDBCQUFBQSxpQkFBaUJ2QixJQUFJLGNBQXJCdUIsOENBQUFBLHdCQUF1QkYsTUFBTTtnQkFDdEMsT0FBTztvQkFDTDFELFFBQVFELEtBQUssQ0FBQyw4QkFBOEI2RCxpQkFBaUI3RCxLQUFLO2dCQUNwRTtZQUNGLE9BQU87b0JBRUh3RCw4QkFBQUEsdUJBQ0tBO2dCQUZQdkQsUUFBUXVCLEdBQUcsQ0FBQyxnQ0FDVmdDLHdCQUFBQSxlQUFlbEIsSUFBSSxjQUFuQmtCLDZDQUFBQSwrQkFBQUEsc0JBQXFCRyxNQUFNLGNBQTNCSCxtREFBQUEsNkJBQTZCSSxjQUFjO2dCQUM3QyxRQUFPSix3QkFBQUEsZUFBZWxCLElBQUksY0FBbkJrQiw0Q0FBQUEsc0JBQXFCRyxNQUFNO1lBQ3BDO1FBQ0YsRUFBRSxPQUFPM0QsT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMscUNBQ1pBLGlCQUFpQjJDLFFBQVEzQyxNQUFNNEMsT0FBTyxHQUFHO1FBQzdDO0lBQ0Y7SUFFQSxpRUFBaUU7SUFDakUsTUFBTW9CLGVBQWU7WUFBT0MsOEVBQWE7UUFDdkMsTUFBTUMsY0FBYztRQUNwQixNQUFNQyxhQUFhLE1BQU0seUJBQXlCO1FBRWxELElBQUk7Z0JBWXdCbEM7WUFYMUJZLGFBQWEseUJBQXlCO2dCQUFFb0I7WUFBVztZQUVuRCxrQ0FBa0M7WUFDbEMsSUFBSUEsYUFBYSxHQUFHO2dCQUNsQixNQUFNRyxRQUFRRCxhQUFhRSxLQUFLQyxHQUFHLENBQUMsR0FBR0wsY0FBZSxLQUFJSSxLQUFLRSxNQUFNLEVBQUM7Z0JBQ3RFLE1BQU0sSUFBSUMsUUFBUUMsQ0FBQUEsVUFBV0MsV0FBV0QsU0FBU0w7WUFDbkQ7WUFFQSwyQ0FBMkM7WUFDM0MsTUFBTW5DLFdBQVcsTUFBTTdELDJEQUFRLENBQXFDRCx5REFBYUEsQ0FBQ2dFLElBQUksQ0FBQ3dDLGFBQWEsRUFBRSxDQUFDO1lBRXZHLElBQUksQ0FBQzFDLFNBQVNJLE9BQU8sSUFBSSxHQUFDSixpQkFBQUEsU0FBU0ssSUFBSSxjQUFiTCxxQ0FBQUEsZUFBZS9DLEtBQUssR0FBRTtnQkFDOUMsTUFBTSxJQUFJeUQsTUFBTTtZQUNsQjtZQUVBLE1BQU0sRUFBRXpELEtBQUssRUFBRU8sUUFBUSxFQUFFLEdBQUd3QyxTQUFTSyxJQUFJO1lBRXpDLG9FQUFvRTtZQUNwRSxNQUFNc0MsaUJBQWlCekIsYUFBYTlDLE9BQU8sQ0FBQzNCLHVEQUFTQSxNQUFNO1lBQzNELE1BQU1tRyxhQUFhRCxnQkFBZ0IsbURBQW1EO1lBRXRGLCtDQUErQztZQUMvQyxNQUFNcEcsZ0VBQWNBLENBQUNVLE9BQU8yRjtZQUU1QiwyQkFBMkI7WUFDM0IzRCxTQUFTaEM7WUFDVCtCLG1CQUFtQjtZQUVuQix3Q0FBd0M7WUFDeEMsSUFBSXhCLFVBQVU7Z0JBQ1pvQixRQUFRaUUsQ0FBQUEsV0FBYTt3QkFBRSxHQUFHQSxRQUFRO3dCQUFFckY7b0JBQVM7WUFDL0M7WUFFQW9ELGFBQWEseUJBQXlCO2dCQUFFcEQ7WUFBUztZQUNqRCxPQUFPO1FBQ1QsRUFBRSxPQUFPTyxPQUFPO1lBQ2QsTUFBTStFLGVBQWUvRSxpQkFBaUIyQyxRQUFRM0MsTUFBTTRDLE9BQU8sR0FBRztZQUU5REMsYUFBYSx5QkFBeUI7Z0JBQ3BDa0M7Z0JBQ0FkO2dCQUNBZSxZQUFZaEYsaUJBQWlCMkMsUUFBUTNDLE1BQU1pRixLQUFLLEdBQUdDO1lBQ3JEO1lBRUEsNEJBQTRCO1lBQzVCLElBQUlqQixhQUFhQyxhQUFhO2dCQUM1QmpFLFFBQVFDLElBQUksQ0FBQyx5QkFBd0MsT0FBZitELGFBQWEsR0FBRTtnQkFDckQsT0FBT0QsYUFBYUMsYUFBYTtZQUNuQztZQUVBLDJDQUEyQztZQUMzQ2hFLFFBQVFELEtBQUssQ0FBQztZQUNkbUY7WUFDQSxPQUFPO1FBQ1Q7SUFDRjtJQUVBLHlCQUF5QjtJQUN6QixNQUFNOUQsUUFBUSxPQUFPaUI7UUFDbkIsSUFBSTtZQUNGckMsUUFBUXVCLEdBQUcsQ0FBQyxpREFBaURjO1lBQzdELGdGQUFnRjtZQUNoRiwwRUFBMEU7WUFDMUUsSUFBSSxDQUFDQSxLQUFLcEQsS0FBSyxFQUFFO2dCQUNmLE1BQU1rRyxjQUFjN0csOERBQVlBO2dCQUNoQzBCLFFBQVF1QixHQUFHLENBQUMsOERBQThELENBQUMsQ0FBQzREO2dCQUM1RSxJQUFJQSxhQUFhO29CQUNmOUMsS0FBS3BELEtBQUssR0FBR2tHO2dCQUNmLE9BQU87b0JBQ0wsTUFBTSxJQUFJekMsTUFBTTtnQkFDbEI7WUFDRjtZQUVBMUMsUUFBUXVCLEdBQUcsQ0FBQztZQUVaLHNEQUFzRDtZQUN0RCxNQUFNcUQsYUFBYXZDLEtBQUsrQyxXQUFXLEtBQUtILFlBQVk1QyxLQUFLK0MsV0FBVyxHQUFHLE1BQU0sdUNBQXVDO1lBRXBILDBDQUEwQztZQUMxQyxNQUFNN0csZ0VBQWNBLENBQUM4RCxLQUFLcEQsS0FBSyxFQUFFMkY7WUFDakM1RSxRQUFRdUIsR0FBRyxDQUFDO1lBRVosMkJBQTJCO1lBQzNCTixTQUFTb0IsS0FBS3BELEtBQUssR0FBRyxxQ0FBcUM7WUFDM0QyQixRQUFReUIsS0FBS3JELElBQUksSUFBSSxDQUFDO1lBQ3RCZ0MsbUJBQW1CO1lBQ25CRixXQUFXLFFBQVEscUNBQXFDO1lBQ3hEZCxRQUFRdUIsR0FBRyxDQUFDLDZEQUE2RGMsS0FBS3JELElBQUk7WUFFbEYsc0RBQXNEO1lBQ3RELElBQUlxRCxLQUFLckQsSUFBSSxFQUFFO2dCQUNiSCxtQkFBbUJFLGVBQWUsQ0FBQ3NELEtBQUtyRCxJQUFJLEVBQUVxRCxLQUFLcEQsS0FBSztZQUMxRDtZQUVBLG1FQUFtRTtZQUNuRWtDLHdCQUF3QjtZQUV4QixvQ0FBb0M7WUFDcENuQixRQUFRdUIsR0FBRyxDQUFDO1lBRVosd0RBQXdEO1lBQ3hELHFEQUFxRDtZQUNyRGtELFdBQVc7Z0JBQ1RuQjtZQUNGLEdBQUcsTUFBTSxrREFBa0Q7WUFFM0QsT0FBTyxNQUFNLDBCQUEwQjtRQUN6QyxFQUFFLE9BQU92RCxPQUFPO1lBQ2RDLFFBQVFELEtBQUssQ0FBQyxpQkFBaUJBLGlCQUFpQjJDLFFBQVEzQyxNQUFNNEMsT0FBTyxHQUFHO1lBQ3hFLDRDQUE0QztZQUM1Q25FLGlFQUFlQTtZQUNmSyxtQkFBbUJLLGFBQWE7WUFFaEMrQixTQUFTO1lBQ1RMLFFBQVE7WUFDUkksbUJBQW1CO1lBQ25CRixXQUFXO1lBRVgsT0FBTyxPQUFPLHNCQUFzQjtRQUN0QztJQUNGO0lBRUEsdUVBQXVFO0lBQ3ZFLE1BQU0wQixpQkFBaUI7UUFDckJoRSxpRUFBZUE7UUFDZnlDLFNBQVM7UUFDVEwsUUFBUTtRQUNSSSxtQkFBbUI7UUFDbkJuQyxtQkFBbUJLLGFBQWE7SUFDbEM7SUFFQSxtQkFBbUI7SUFDbkIsTUFBTWdHLFNBQVM7UUFDYnRDLGFBQWE7UUFDYixJQUFJO1lBQ0YscURBQXFEO1lBQ3JELElBQUl0RSw4REFBWUEsSUFBSTtnQkFDbEIsTUFBTUgsMkRBQVEsQ0FBQ0QseURBQWFBLENBQUNnRSxJQUFJLENBQUNtRCxNQUFNLEVBQUUsQ0FBQztZQUM3QztRQUNGLEVBQUUsT0FBT3RGLE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLHdCQUF3QkE7UUFDdEMsZ0RBQWdEO1FBQ2xELFNBQVU7WUFDUix1Q0FBdUM7WUFDdkN5QztZQUVBLGdCQUFnQjtZQUNoQkksYUFBYTtRQUNmO0lBQ0Y7SUFFQSxxQkFDRSw4REFBQ25DLFlBQVk2RSxRQUFRO1FBQUNDLE9BQU87WUFDM0J2RztZQUNBb0M7WUFDQThEO1lBQ0FyRTtZQUNBa0Q7WUFDQWhEO1FBQ0Y7a0JBQ0dKOzs7Ozs7QUFHUDtHQWxXZ0JEO0tBQUFBO0FBb1dULE1BQU04RSxVQUFVOztJQUNyQixNQUFNQyxVQUFVM0gsaURBQVVBLENBQUMyQztJQUMzQixJQUFJLENBQUNnRixTQUFTO1FBQ1osTUFBTSxJQUFJL0MsTUFBTTtJQUNsQjtJQUNBLE9BQU8rQztBQUNULEVBQUU7SUFOV0QiLCJzb3VyY2VzIjpbIi9ob21lL3VidW50dS9ncmFjZS1wcm9qZWN0L3NyYy91aS9jb21wb25lbnRzL0F1dGhDb250ZXh0LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvdWkvY29tcG9uZW50cy9BdXRoQ29udGV4dC50c3hcblxuaW1wb3J0IFJlYWN0LCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZUVmZmVjdCwgdXNlU3RhdGUsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEFQSV9FTkRQT0lOVFMgfSBmcm9tICcuLi9hcGkvYXBpQ2xpZW50JztcbmltcG9ydCBhcGkgZnJvbSAnLi4vYXBpL2FwaUNsaWVudCc7XG4vLyBJbXBvcnQgYWRtaW4gYmFja2Rvb3IgdXRpbGl0aWVzXG5pbXBvcnQgeyBoYXNBZG1pbkJ5cGFzcywgYnlwYXNzTG9naW4gfSBmcm9tICcuLi91dGlscy9kZXZBdXRoJztcbi8vIEltcG9ydCBzdGFuZGFyZGl6ZWQgYXV0aCB1dGlsc1xuaW1wb3J0IHtcbiAgZ2V0QXV0aFRva2VuLFxuICBnZXRUb2tlbkV4cGlyeSxcbiAgc3RvcmVBdXRoVG9rZW4sXG4gIGNsZWFyQXV0aFRva2VucyxcbiAgaXNUb2tlbkV4cGlyZWQsXG4gIGFkZEF1dGhIZWFkZXJzLFxuICBUT0tFTl9LRVlcbn0gZnJvbSAnLi4vdXRpbHMvYXV0aFV0aWxzJztcblxuY29uc3QgVE9LRU5fRVhQSVJZX0tFWSA9ICdncmFjZV90b2tlbl9leHBpcnknO1xuY29uc3QgUkVGUkVTSF9UT0tFTl9LRVkgPSAnZ3JhY2VfcmVmcmVzaF90b2tlbic7XG5jb25zdCBUT0tFTl9WRVJJRllfSU5URVJWQUwgPSA2MDAwMDsgLy8gQ2hlY2sgdG9rZW4gdmFsaWRpdHkgZXZlcnkgNjAgc2Vjb25kc1xuXG4vLyBJbXByb3ZlZCBzZXNzaW9uIHBlcnNpc3RlbmNlIHV0aWxpdHkgdG8gYXZvaWQgY29uZmxpY3RzIHdpdGggZm9ybSBzdGF0ZVxuY29uc3QgU2Vzc2lvblBlcnNpc3RlbmNlID0ge1xuICBTVE9SQUdFX0tFWTogJ0dSQUNFX1NFU1NJT05fU05BUFNIT1QnLFxuICBcbiAgLy8gU2FmZWx5IGNhcHR1cmUgc2Vzc2lvbiBzbmFwc2hvdCB3aXRoIG1pbmltYWwgZGF0YSB0byBhdm9pZCBpbnRlcmZlcmVuY2VcbiAgY2FwdHVyZVNuYXBzaG90KHVzZXI6IFVzZXIgfCBudWxsLCB0b2tlbjogc3RyaW5nIHwgbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIXVzZXIgfHwgIXRva2VuKSB7XG4gICAgICAgIHRoaXMuY2xlYXJTbmFwc2hvdCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFN0b3JlIG9ubHkgZXNzZW50aWFsIHVzZXIgaWRlbnRpZmljYXRpb24gZGF0YVxuICAgICAgLy8gQXZvaWQgc3RvcmluZyBjb21wbGV0ZSBzdGF0ZSB0aGF0IG1pZ2h0IGNvbmZsaWN0IHdpdGggZm9ybXNcbiAgICAgIGNvbnN0IHNuYXBzaG90ID0ge1xuICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgIHVzZXI6IHtcbiAgICAgICAgICBpZDogdXNlci5pZCxcbiAgICAgICAgICB1c2VybmFtZTogdXNlci51c2VybmFtZSxcbiAgICAgICAgICBlbWFpbDogdXNlci5lbWFpbFxuICAgICAgICB9LFxuICAgICAgICAvLyBEb24ndCBzdG9yZSB0aGUgYWN0dWFsIHRva2VuLCBqdXN0IGluZGljYXRlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgIGF1dGhlbnRpY2F0ZWQ6IHRydWVcbiAgICAgIH07XG5cbiAgICAgIC8vIFVzZSBzZXNzaW9uU3RvcmFnZSBpbnN0ZWFkIG9mIGxvY2FsU3RvcmFnZSB0byBhdm9pZCBwZXJzaXN0aW5nIGJldHdlZW4gYnJvd3NlciBzZXNzaW9uc1xuICAgICAgLy8gVGhpcyBoZWxwcyBwcmV2ZW50IHN0YWxlIGRhdGEgZnJvbSBhZmZlY3RpbmcgZm9ybXMgb24gZnV0dXJlIHZpc2l0c1xuICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbSh0aGlzLlNUT1JBR0VfS0VZLCBKU09OLnN0cmluZ2lmeShzbmFwc2hvdCkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBjYXB0dXJlIHNlc3Npb24gc25hcHNob3QnLCBlcnJvcik7XG4gICAgICAvLyBTaWxlbnRseSBmYWlsIC0gZG9uJ3QgbGV0IHNuYXBzaG90IGVycm9ycyBhZmZlY3QgdGhlIGFwcGxpY2F0aW9uXG4gICAgfVxuICB9LFxuXG4gIC8vIFJldHJpZXZlIHNlc3Npb24gc25hcHNob3Qgd2l0aCB2YWxpZGF0aW9uXG4gIHJldHJpZXZlU25hcHNob3QoKTogeyB1c2VyOiBVc2VyIHwgbnVsbCwgdG9rZW46IHN0cmluZyB8IG51bGwgfSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNuYXBzaG90U3RyID0gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbSh0aGlzLlNUT1JBR0VfS0VZKTtcbiAgICAgIGlmICghc25hcHNob3RTdHIpIHJldHVybiB7IHVzZXI6IG51bGwsIHRva2VuOiBudWxsIH07XG5cbiAgICAgIGNvbnN0IHNuYXBzaG90ID0gSlNPTi5wYXJzZShzbmFwc2hvdFN0cik7XG4gICAgICBcbiAgICAgIC8vIFZhbGlkYXRlIHNuYXBzaG90IHdpdGggZXhwaXJhdGlvbiBjaGVjayAoMzAgbWludXRlcylcbiAgICAgIGNvbnN0IE1BWF9BR0UgPSAzMCAqIDYwICogMTAwMDsgLy8gMzAgbWludXRlcyBpbiBtaWxsaXNlY29uZHNcbiAgICAgIGNvbnN0IGlzRXhwaXJlZCA9IChEYXRlLm5vdygpIC0gKHNuYXBzaG90LnRpbWVzdGFtcCB8fCAwKSkgPiBNQVhfQUdFO1xuICAgICAgXG4gICAgICBpZiAoc25hcHNob3QgJiYgc25hcHNob3QudXNlciAmJiAhaXNFeHBpcmVkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdXNlcjogc25hcHNob3QudXNlcixcbiAgICAgICAgICAvLyBHZXQgYWN0dWFsIHRva2VuIGZyb20gYXV0aFV0aWxzIHRvIGVuc3VyZSBjb25zaXN0ZW5jeVxuICAgICAgICAgIHRva2VuOiBnZXRBdXRoVG9rZW4oKVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBDbGVhciBleHBpcmVkIHNuYXBzaG90XG4gICAgICBpZiAoaXNFeHBpcmVkKSB0aGlzLmNsZWFyU25hcHNob3QoKTtcbiAgICAgIHJldHVybiB7IHVzZXI6IG51bGwsIHRva2VuOiBudWxsIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHJldHJpZXZlIHNlc3Npb24gc25hcHNob3QnLCBlcnJvcik7XG4gICAgICB0aGlzLmNsZWFyU25hcHNob3QoKTsgLy8gQ2xlYXIgaW52YWxpZCBzbmFwc2hvdFxuICAgICAgcmV0dXJuIHsgdXNlcjogbnVsbCwgdG9rZW46IG51bGwgfTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gQ2xlYXIgc2Vzc2lvbiBzbmFwc2hvdFxuICBjbGVhclNuYXBzaG90KCkge1xuICAgIHRyeSB7XG4gICAgICBzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKHRoaXMuU1RPUkFHRV9LRVkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBjbGVhciBzZXNzaW9uIHNuYXBzaG90JywgZXJyb3IpO1xuICAgIH1cbiAgfVxufTtcblxuaW50ZXJmYWNlIFVzZXIge1xuICBpZD86IHN0cmluZztcbiAgdXNlcm5hbWU/OiBzdHJpbmc7XG4gIGVtYWlsPzogc3RyaW5nO1xuICBba2V5OiBzdHJpbmddOiBhbnk7XG59XG5cbmludGVyZmFjZSBBdXRoQ29udGV4dFR5cGUge1xuICB1c2VyOiBVc2VyIHwgbnVsbDtcbiAgbG9naW46IChkYXRhOiBhbnkpID0+IFByb21pc2U8Ym9vbGVhbj47XG4gIGxvZ291dDogKCkgPT4gdm9pZDtcbiAgbG9hZGluZzogYm9vbGVhbjtcbiAgcmVmcmVzaFRva2VuOiAoKSA9PiBQcm9taXNlPGJvb2xlYW4+O1xuICBpc0F1dGhlbnRpY2F0ZWQ6IGJvb2xlYW47XG59XG5cbmNvbnN0IEF1dGhDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxBdXRoQ29udGV4dFR5cGUgfCBudWxsPihudWxsKTtcblxuXG5leHBvcnQgZnVuY3Rpb24gQXV0aFByb3ZpZGVyKHsgY2hpbGRyZW4gfTogeyBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlIH0pIHtcbiAgY29uc3QgW3VzZXIsIHNldFVzZXJdID0gdXNlU3RhdGU8VXNlciB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZTxib29sZWFuPih0cnVlKTtcbiAgY29uc3QgW2lzQXV0aGVudGljYXRlZCwgc2V0SXNBdXRoZW50aWNhdGVkXSA9IHVzZVN0YXRlPGJvb2xlYW4+KGZhbHNlKTtcbiAgLy8gVXNlIHN0YXRlIGZvciB0b2tlbiB0byBlbnN1cmUgaXQncyB1cGRhdGVkIHdoZW4gY2hhbmdlZFxuICBjb25zdCBbdG9rZW4sIHNldFRva2VuXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KGdldEF1dGhUb2tlbigpKTtcbiAgLy8gQWRkIGZsYWcgdG8gcHJldmVudCB2ZXJpZmljYXRpb24gaW1tZWRpYXRlbHkgYWZ0ZXIgbG9naW5cbiAgY29uc3QgW3NraXBOZXh0VmVyaWZpY2F0aW9uLCBzZXRTa2lwTmV4dFZlcmlmaWNhdGlvbl0gPSB1c2VTdGF0ZTxib29sZWFuPihmYWxzZSk7XG4gIFxuICAvLyBVcGRhdGUgdG9rZW4gc3RhdGUgd2hlbmV2ZXIgYXV0aCBzdGF0ZSBjaGFuZ2VzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgc2V0VG9rZW4oZ2V0QXV0aFRva2VuKCkpO1xuICB9LCBbaXNBdXRoZW50aWNhdGVkXSk7XG4gIFxuICAvLyBBZG1pbiBiYWNrZG9vciBmb3IgcXVpY2sgYWNjZXNzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gQ2hlY2sgaWYgd2Ugc2hvdWxkIHVzZSB0aGUgYWRtaW4gYmFja2Rvb3JcbiAgICBpZiAoaGFzQWRtaW5CeXBhc3MoKSAmJiAhaXNBdXRoZW50aWNhdGVkICYmICF0b2tlbikge1xuICAgICAgYnlwYXNzTG9naW4obG9naW4pO1xuICAgIH1cbiAgfSwgW10pO1xuXG4gIC8vIEZJWEVEOiBTdGFiaWxpemVkIHZlcmlmaWNhdGlvbiBvbiBtb3VudCBhbmQgcGVyaW9kaWMgY2hlY2tzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbGV0IGlzTW91bnRlZCA9IHRydWU7XG4gICAgXG4gICAgY29uc3QgdmVyaWZ5T25Nb3VudCA9IGFzeW5jICgpID0+IHtcbiAgICAgIC8vIFNraXAgaW5pdGlhbCB2ZXJpZmljYXRpb24gaWYgdGhlcmUncyBubyB0b2tlblxuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICFnZXRBdXRoVG9rZW4oKSkge1xuICAgICAgICBjb25zb2xlLmxvZygnQXV0aENvbnRleHQ6IE5vIHRva2VuIGZvdW5kIG9uIG1vdW50LCBza2lwcGluZyB2ZXJpZmljYXRpb24nKTtcbiAgICAgICAgaWYgKGlzTW91bnRlZCkgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ0F1dGhDb250ZXh0OiBWZXJpZnlpbmcgdG9rZW4gb24gbW91bnQnKTtcbiAgICAgIC8vIFZlcmlmeSB0b2tlbiBvbiBjb21wb25lbnQgbW91bnQgKGZvcmNlID0gdHJ1ZSB0byBieXBhc3MgZGVib3VuY2luZylcbiAgICAgIGF3YWl0IHZlcmlmeVRva2VuKHRydWUpO1xuICAgICAgXG4gICAgICAvLyBIYW5kbGUgY2FzZSB3aGVyZSB2ZXJpZmljYXRpb24gY29tcGxldGVkIGJ1dCBjb21wb25lbnQgd2FzIHVubW91bnRlZFxuICAgICAgaWYgKGlzTW91bnRlZCkgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgfTtcbiAgICBcbiAgICB2ZXJpZnlPbk1vdW50KCk7XG4gICAgXG4gICAgLy8gRklYRUQ6IEluY3JlYXNlZCBpbnRlcnZhbCB0byByZWR1Y2UgdmVyaWZpY2F0aW9uIGZyZXF1ZW5jeVxuICAgIGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgaWYgKCFza2lwTmV4dFZlcmlmaWNhdGlvbikge1xuICAgICAgICB2ZXJpZnlUb2tlbigpOyAvLyBVc2UgZGVib3VuY2VkIHZlcnNpb24gZm9yIHBlcmlvZGljIGNoZWNrc1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmVzZXQgc2tpcCBmbGFnIGFmdGVyIHVzaW5nIGl0IG9uY2VcbiAgICAgICAgc2V0U2tpcE5leHRWZXJpZmljYXRpb24oZmFsc2UpO1xuICAgICAgfVxuICAgIH0sIDEyMDAwMCk7IC8vIEZJWEVEOiBJbmNyZWFzZWQgdG8gMiBtaW51dGVzIHRvIHJlZHVjZSBzZXJ2ZXIgbG9hZFxuICAgIFxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpc01vdW50ZWQgPSBmYWxzZTtcbiAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgIH07XG4gIH0sIFtdKTsgICAgIFxuXG4gIC8vIEZJWEVEOiBBZGQgZGVib3VuY2luZyB0byBwcmV2ZW50IHJhcGlkIHZlcmlmaWNhdGlvbiBjYWxsc1xuICBjb25zdCB2ZXJpZnlUb2tlbkRlYm91bmNlZCA9IHVzZVJlZjxOb2RlSlMuVGltZW91dCB8IG51bGw+KG51bGwpO1xuICBjb25zdCBsYXN0VmVyaWZ5QXR0ZW1wdCA9IHVzZVJlZjxudW1iZXI+KDApO1xuICBcbiAgLy8gVmVyaWZ5IHVzZXIgdG9rZW4gd2l0aCBiYWNrZW5kIChGSVhFRDogQWRkZWQgZGVib3VuY2luZyBhbmQgYmV0dGVyIGVycm9yIGhhbmRsaW5nKVxuICBjb25zdCB2ZXJpZnlUb2tlbiA9IGFzeW5jIChmb3JjZTogYm9vbGVhbiA9IGZhbHNlKSA9PiB7XG4gICAgLy8gSWYgbm8gdG9rZW4gZXhpc3RzLCB0aGVyZSdzIG5vdGhpbmcgdG8gdmVyaWZ5XG4gICAgY29uc3QgdG9rZW4gPSBnZXRBdXRoVG9rZW4oKTtcbiAgICBpZiAoIXRva2VuKSB7XG4gICAgICBjb25zb2xlLmxvZygnQXV0aENvbnRleHQ6IE5vIHRva2VuIHRvIHZlcmlmeScpO1xuICAgICAgc2V0SXNBdXRoZW50aWNhdGVkKGZhbHNlKTtcbiAgICAgIHNldFVzZXIobnVsbCk7XG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBGSVhFRDogRGVib3VuY2UgdmVyaWZpY2F0aW9uIGNhbGxzIHRvIHByZXZlbnQgcmFwaWQgcmVxdWVzdHNcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGlmICghZm9yY2UgJiYgbm93IC0gbGFzdFZlcmlmeUF0dGVtcHQuY3VycmVudCA8IDUwMDApIHtcbiAgICAgIGNvbnNvbGUubG9nKCdBdXRoQ29udGV4dDogU2tpcHBpbmcgdmVyaWZpY2F0aW9uIChkZWJvdW5jZWQpJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxhc3RWZXJpZnlBdHRlbXB0LmN1cnJlbnQgPSBub3c7XG5cbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJ0F1dGhDb250ZXh0OiBWZXJpZnlpbmcgdG9rZW4gd2l0aCBiYWNrZW5kJyk7XG4gICAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkuZ2V0KEFQSV9FTkRQT0lOVFMuQVVUSC5WRVJJRllfVE9LRU4pO1xuXG4gICAgICBpZiAocmVzcG9uc2Uuc3VjY2VzcyAmJiByZXNwb25zZS5kYXRhKSB7XG4gICAgICAgIC8vIFRva2VuIGlzIHZhbGlkLCB1cGRhdGUgdXNlciBkYXRhXG4gICAgICAgIGNvbnNvbGUubG9nKCdBdXRoQ29udGV4dDogVG9rZW4gdmVyaWZpZWQgc3VjY2Vzc2Z1bGx5Jyk7XG4gICAgICAgIHNldElzQXV0aGVudGljYXRlZCh0cnVlKTtcbiAgICAgICAgc2V0VXNlcihyZXNwb25zZS5kYXRhLnVzZXIgfHwge30pO1xuICAgICAgICBzZXRUb2tlbih0b2tlbik7IC8vIEVuc3VyZSB0b2tlbiBzdGF0ZSBtYXRjaGVzIHN0b3JhZ2VcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIE5vbi1zdWNjZXNzIEhUVFAgcmVzcG9uc2VcbiAgICAgIGNvbnN0IHN0YXR1cyA9IHJlc3BvbnNlLnN0YXR1c0NvZGUgPz8gMDtcbiAgICAgIGlmIChzdGF0dXMgPT09IDQwMSB8fCBzdGF0dXMgPT09IDQwMykge1xuICAgICAgICBjb25zb2xlLmxvZygnQXV0aENvbnRleHQ6IFRva2VuIHZlcmlmaWNhdGlvbiBmYWlsZWQgd2l0aCB1bmF1dGhvcml6ZWQgc3RhdHVzOicsIHN0YXR1cyk7XG4gICAgICAgIGNsZWFyQXV0aFN0YXRlKCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gRklYRUQ6IEZvciBvdGhlciBlcnJvcnMgKDV4eCwgMCwgZXRjLiksIGtlZXAgY3VycmVudCBhdXRoIHN0YXRlIHRvIGF2b2lkIGZsaWNrZXJcbiAgICAgIGNvbnNvbGUud2FybignQXV0aENvbnRleHQ6IFZlcmlmaWNhdGlvbiBub24tc3VjY2VzcyBidXQgbm90IHVuYXV0aG9yaXplZC4gUHJlc2VydmluZyBhdXRoIHN0YXRlLicsIHtcbiAgICAgICAgc3RhdHVzLFxuICAgICAgICBlcnJvcjogcmVzcG9uc2UuZXJyb3JcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBGSVhFRDogTmV0d29yayBvciB1bmV4cGVjdGVkIGVycm9yOiBwcmVzZXJ2ZSBjdXJyZW50IGF1dGggc3RhdGUgdG8gcHJldmVudCBib3VuY2luZ1xuICAgICAgY29uc3QgbXNnID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcic7XG4gICAgICBjb25zb2xlLmVycm9yKCdUb2tlbiB2ZXJpZmljYXRpb24gZXJyb3IsIHByZXNlcnZpbmcgYXV0aCBzdGF0ZTonLCBtc2cpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gRW5oYW5jZWQgbG9nZ2luZyB1dGlsaXR5IGZvciBhdXRoZW50aWNhdGlvbiBldmVudHNcbiAgY29uc3QgbG9nQXV0aEV2ZW50ID0gKGV2ZW50VHlwZTogc3RyaW5nLCBkZXRhaWxzOiBhbnkgPSB7fSkgPT4ge1xuICAgIGNvbnN0IHRpbWVzdGFtcCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICBjb25zdCBsb2dFbnRyeSA9IHtcbiAgICAgIHRpbWVzdGFtcCxcbiAgICAgIGV2ZW50VHlwZSxcbiAgICAgIC4uLmRldGFpbHNcbiAgICB9O1xuICAgIFxuICAgIC8vIE9wdGlvbmFsOiBTZW5kIHRvIGJhY2tlbmQgbG9nZ2luZyBzZXJ2aWNlIG9yIHN0b3JlIGxvY2FsbHlcbiAgICBjb25zb2xlLmxvZyhKU09OLnN0cmluZ2lmeShsb2dFbnRyeSkpO1xuICAgIFxuICAgIC8vIFN0b3JlIGluIGxvY2FsIHN0b3JhZ2UgZm9yIHBvdGVudGlhbCBkZWJ1Z2dpbmdcbiAgICB0cnkge1xuICAgICAgY29uc3QgYXV0aExvZ3MgPSBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdhdXRoX2xvZ3MnKSB8fCAnW10nKTtcbiAgICAgIGF1dGhMb2dzLnB1c2gobG9nRW50cnkpO1xuICAgICAgLy8gS2VlcCBvbmx5IGxhc3QgNTAgbG9nIGVudHJpZXNcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdhdXRoX2xvZ3MnLCBKU09OLnN0cmluZ2lmeShhdXRoTG9ncy5zbGljZSgtNTApKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGxvZyBhdXRoZW50aWNhdGlvbiBldmVudCcsIGUpO1xuICAgIH1cbiAgfTtcblxuICAvLyBDaGVjayBpZiB1c2VyIGhhcyBhIHdhbGxldCBhbmQgZ2VuZXJhdGUgb25lIGlmIG5vdCBhdmFpbGFibGVcbiAgY29uc3QgY2hlY2tBbmRHZW5lcmF0ZVdhbGxldCA9IGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgLy8gU2tpcCBpZiBub3QgYXV0aGVudGljYXRlZFxuICAgICAgaWYgKCFpc0F1dGhlbnRpY2F0ZWQgfHwgIXRva2VuKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gRmlyc3QgY2hlY2sgaWYgd2FsbGV0IGFscmVhZHkgZXhpc3RzXG4gICAgICBjb25zdCB3YWxsZXRSZXNwb25zZSA9IGF3YWl0IGFwaS5nZXQoQVBJX0VORFBPSU5UUy5XQUxMRVQuSU5GTywge30pO1xuICAgICAgXG4gICAgICAvLyBJZiBubyB3YWxsZXQgb3Igd2FsbGV0IGFkZHJlc3MgaXMgZW1wdHksIGdlbmVyYXRlIGEgbmV3IG9uZVxuICAgICAgaWYgKCF3YWxsZXRSZXNwb25zZS5zdWNjZXNzIHx8IFxuICAgICAgICAgICF3YWxsZXRSZXNwb25zZS5kYXRhPy53YWxsZXQ/LndhbGxldF9hZGRyZXNzKSB7XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZygnTm8gd2FsbGV0IGZvdW5kIGZvciB1c2VyLCBnZW5lcmF0aW5nIGEgbmV3IGludGVybmFsIHdhbGxldC4uLicpO1xuICAgICAgICBcbiAgICAgICAgLy8gR2VuZXJhdGUgYSBuZXcgd2FsbGV0XG4gICAgICAgIGNvbnN0IGdlbmVyYXRlUmVzcG9uc2UgPSBhd2FpdCBhcGkucG9zdChBUElfRU5EUE9JTlRTLldBTExFVC5HRU5FUkFURSwge30pO1xuICAgICAgICBcbiAgICAgICAgaWYgKGdlbmVyYXRlUmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdXYWxsZXQgZ2VuZXJhdGVkIHN1Y2Nlc3NmdWxseTonLCBcbiAgICAgICAgICAgIGdlbmVyYXRlUmVzcG9uc2UuZGF0YT8ud2FsbGV0Py53YWxsZXRfYWRkcmVzcyk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gWW91IGNvdWxkIHNldCB3YWxsZXQgaW5mbyBpbiBzdGF0ZSBoZXJlIGlmIG5lZWRlZFxuICAgICAgICAgIHJldHVybiBnZW5lcmF0ZVJlc3BvbnNlLmRhdGE/LndhbGxldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZ2VuZXJhdGUgd2FsbGV0OicsIGdlbmVyYXRlUmVzcG9uc2UuZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZygnVXNlciB3YWxsZXQgYWxyZWFkeSBleGlzdHM6JywgXG4gICAgICAgICAgd2FsbGV0UmVzcG9uc2UuZGF0YT8ud2FsbGV0Py53YWxsZXRfYWRkcmVzcyk7XG4gICAgICAgIHJldHVybiB3YWxsZXRSZXNwb25zZS5kYXRhPy53YWxsZXQ7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNoZWNraW5nL2dlbmVyYXRpbmcgd2FsbGV0OicsIFxuICAgICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJyk7XG4gICAgfVxuICB9O1xuXG4gIC8vIEltcGxlbWVudCB0b2tlbiByZWZyZXNoIGZ1bmN0aW9uYWxpdHkgd2l0aCBleHBvbmVudGlhbCBiYWNrb2ZmXG4gIGNvbnN0IHJlZnJlc2hUb2tlbiA9IGFzeW5jIChyZXRyeUNvdW50ID0gMCk6IFByb21pc2U8Ym9vbGVhbj4gPT4ge1xuICAgIGNvbnN0IE1BWF9SRVRSSUVTID0gMztcbiAgICBjb25zdCBCQVNFX0RFTEFZID0gMTAwMDsgLy8gMSBzZWNvbmQgaW5pdGlhbCBkZWxheVxuXG4gICAgdHJ5IHtcbiAgICAgIGxvZ0F1dGhFdmVudCgnVE9LRU5fUkVGUkVTSF9BVFRFTVBUJywgeyByZXRyeUNvdW50IH0pO1xuXG4gICAgICAvLyBFeHBvbmVudGlhbCBiYWNrb2ZmIHdpdGggaml0dGVyXG4gICAgICBpZiAocmV0cnlDb3VudCA+IDApIHtcbiAgICAgICAgY29uc3QgZGVsYXkgPSBCQVNFX0RFTEFZICogTWF0aC5wb3coMiwgcmV0cnlDb3VudCkgKiAoMSArIE1hdGgucmFuZG9tKCkpO1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgZGVsYXkpKTtcbiAgICAgIH1cblxuICAgICAgLy8gVXNlIHRoZSBkZWRpY2F0ZWQgcmVmcmVzaCB0b2tlbiBlbmRwb2ludFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkucG9zdDx7dG9rZW46IHN0cmluZywgdXNlcm5hbWU/OiBzdHJpbmd9PihBUElfRU5EUE9JTlRTLkFVVEguUkVGUkVTSF9UT0tFTiwge30pO1xuICAgICAgXG4gICAgICBpZiAoIXJlc3BvbnNlLnN1Y2Nlc3MgfHwgIXJlc3BvbnNlLmRhdGE/LnRva2VuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVG9rZW4gcmVmcmVzaCBmYWlsZWQ6IEludmFsaWQgcmVzcG9uc2UnKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgeyB0b2tlbiwgdXNlcm5hbWUgfSA9IHJlc3BvbnNlLmRhdGE7XG4gICAgICBcbiAgICAgIC8vIERldGVybWluZSBzdG9yYWdlIHR5cGUgYmFzZWQgb24gd2hlcmUgdGhlIGN1cnJlbnQgdG9rZW4gaXMgc3RvcmVkXG4gICAgICBjb25zdCBpbkxvY2FsU3RvcmFnZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFRPS0VOX0tFWSkgIT09IG51bGw7XG4gICAgICBjb25zdCByZW1lbWJlck1lID0gaW5Mb2NhbFN0b3JhZ2U7IC8vIElmIGluIGxvY2FsU3RvcmFnZSwgdXNlciB3YW50ZWQgcGVyc2lzdGVudCBsb2dpblxuICAgICAgXG4gICAgICAvLyBTdG9yZSB0aGUgbmV3IHRva2VuIHdpdGggdGhlIHNhbWUgcHJlZmVyZW5jZVxuICAgICAgYXdhaXQgc3RvcmVBdXRoVG9rZW4odG9rZW4sIHJlbWVtYmVyTWUpO1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgbG9jYWwgdG9rZW4gc3RhdGVcbiAgICAgIHNldFRva2VuKHRva2VuKTtcbiAgICAgIHNldElzQXV0aGVudGljYXRlZCh0cnVlKTtcbiAgICAgIFxuICAgICAgLy8gT3B0aW9uYWw6IFVwZGF0ZSB1c2VybmFtZSBpZiBwcm92aWRlZFxuICAgICAgaWYgKHVzZXJuYW1lKSB7XG4gICAgICAgIHNldFVzZXIocHJldlVzZXIgPT4gKHsgLi4ucHJldlVzZXIsIHVzZXJuYW1lIH0pKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgbG9nQXV0aEV2ZW50KCdUT0tFTl9SRUZSRVNIX1NVQ0NFU1MnLCB7IHVzZXJuYW1lIH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gcmVmcmVzaCBlcnJvcic7XG4gICAgICBcbiAgICAgIGxvZ0F1dGhFdmVudCgnVE9LRU5fUkVGUkVTSF9GQUlMVVJFJywgeyBcbiAgICAgICAgZXJyb3JNZXNzYWdlLCBcbiAgICAgICAgcmV0cnlDb3VudCxcbiAgICAgICAgZXJyb3JTdGFjazogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLnN0YWNrIDogdW5kZWZpbmVkXG4gICAgICB9KTtcblxuICAgICAgLy8gSW1wbGVtZW50IHJldHJ5IG1lY2hhbmlzbVxuICAgICAgaWYgKHJldHJ5Q291bnQgPCBNQVhfUkVUUklFUykge1xuICAgICAgICBjb25zb2xlLndhcm4oYFRva2VuIHJlZnJlc2ggYXR0ZW1wdCAke3JldHJ5Q291bnQgKyAxfSBmYWlsZWQuIFJldHJ5aW5nLi4uYCk7XG4gICAgICAgIHJldHVybiByZWZyZXNoVG9rZW4ocmV0cnlDb3VudCArIDEpO1xuICAgICAgfVxuXG4gICAgICAvLyBGaW5hbCBmYWxsYmFjazogbG9nb3V0IGFmdGVyIG1heCByZXRyaWVzXG4gICAgICBjb25zb2xlLmVycm9yKCdUb2tlbiByZWZyZXNoIGZhaWxlZCBhZnRlciBtYXhpbXVtIHJldHJpZXMnKTtcbiAgICAgIGxvZ291dCgpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICAvLyBMb2dpbiB3aXRoIGNyZWRlbnRpYWxzXG4gIGNvbnN0IGxvZ2luID0gYXN5bmMgKGRhdGE6IGFueSk6IFByb21pc2U8Ym9vbGVhbj4gPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZygnQXV0aENvbnRleHQ6IGxvZ2luIGZ1bmN0aW9uIGNhbGxlZCB3aXRoIGRhdGE6JywgZGF0YSk7XG4gICAgICAvLyBTb21lIEFQSSBjbGllbnRzIHNhdmUgdGhlIHRva2VuIGRpcmVjdGx5IHRvIHN0b3JhZ2UgYW5kIHN0cmlwIGl0IGZyb20gcGF5bG9hZFxuICAgICAgLy8gRmFsbCBiYWNrIHRvIHJlYWRpbmcgZnJvbSBzdG9yYWdlIGlmIG5vdCBwcmVzZW50IG9uIHRoZSByZXNwb25zZSBvYmplY3RcbiAgICAgIGlmICghZGF0YS50b2tlbikge1xuICAgICAgICBjb25zdCBzdG9yZWRUb2tlbiA9IGdldEF1dGhUb2tlbigpO1xuICAgICAgICBjb25zb2xlLmxvZygnQXV0aENvbnRleHQ6IHRva2VuIG1pc3NpbmcgaW4gcGF5bG9hZCwgdXNpbmcgc3RvcmVkIHRva2VuOicsICEhc3RvcmVkVG9rZW4pO1xuICAgICAgICBpZiAoc3RvcmVkVG9rZW4pIHtcbiAgICAgICAgICBkYXRhLnRva2VuID0gc3RvcmVkVG9rZW47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB0b2tlbiBmb3VuZCBpbiBsb2dpbiBkYXRhIG9yIHN0b3JhZ2UnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygnQXV0aENvbnRleHQ6IFByb2Nlc3NpbmcgbG9naW4gd2l0aCB0b2tlbicpO1xuICAgICAgXG4gICAgICAvLyBTdG9yZSB0b2tlbiB3aXRoIHJlbWVtYmVyIG1lIHByZWZlcmVuY2UgaWYgcHJvdmlkZWRcbiAgICAgIGNvbnN0IHJlbWVtYmVyTWUgPSBkYXRhLnJlbWVtYmVyX21lICE9PSB1bmRlZmluZWQgPyBkYXRhLnJlbWVtYmVyX21lIDogdHJ1ZTsgLy8gRGVmYXVsdCB0byB0cnVlIGZvciBwZXJzaXN0ZW50IGxvZ2luXG4gICAgICBcbiAgICAgIC8vIFN0b3JlIHRva2VuIGFuZCB3YWl0IGZvciBpdCB0byBjb21wbGV0ZVxuICAgICAgYXdhaXQgc3RvcmVBdXRoVG9rZW4oZGF0YS50b2tlbiwgcmVtZW1iZXJNZSk7XG4gICAgICBjb25zb2xlLmxvZygnQXV0aENvbnRleHQ6IFRva2VuIHN0b3JlZCBzdWNjZXNzZnVsbHknKTtcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIGFwcGxpY2F0aW9uIHN0YXRlXG4gICAgICBzZXRUb2tlbihkYXRhLnRva2VuKTsgLy8gRW5zdXJlIHRva2VuIHN0YXRlIGlzIHN5bmNocm9uaXplZFxuICAgICAgc2V0VXNlcihkYXRhLnVzZXIgfHwge30pO1xuICAgICAgc2V0SXNBdXRoZW50aWNhdGVkKHRydWUpO1xuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7IC8vIEVuc3VyZSBsb2FkaW5nIHN0YXRlIGlzIHR1cm5lZCBvZmZcbiAgICAgIGNvbnNvbGUubG9nKCdBdXRoQ29udGV4dDogU3RhdGUgdXBkYXRlZCAtIGlzQXV0aGVudGljYXRlZDogdHJ1ZSwgdXNlcjonLCBkYXRhLnVzZXIpO1xuICAgICAgXG4gICAgICAvLyBDYXB0dXJlIG1pbmltYWwgc2Vzc2lvbiBkYXRhIGFmdGVyIHN1Y2Nlc3NmdWwgbG9naW5cbiAgICAgIGlmIChkYXRhLnVzZXIpIHtcbiAgICAgICAgU2Vzc2lvblBlcnNpc3RlbmNlLmNhcHR1cmVTbmFwc2hvdChkYXRhLnVzZXIsIGRhdGEudG9rZW4pO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBTZXQgZmxhZyB0byBza2lwIG5leHQgdmVyaWZpY2F0aW9uIGN5Y2xlIHRvIGF2b2lkIHJhY2UgY29uZGl0aW9uXG4gICAgICBzZXRTa2lwTmV4dFZlcmlmaWNhdGlvbih0cnVlKTtcbiAgICAgIFxuICAgICAgLy8gTG9nIHN1Y2Nlc3NmdWwgbG9naW4gc3RhdGUgdXBkYXRlXG4gICAgICBjb25zb2xlLmxvZygnQXV0aENvbnRleHQ6IExvZ2luIGNvbXBsZXRlLCBhdXRoIHN0YXRlIHVwZGF0ZWQnKTtcbiAgICAgIFxuICAgICAgLy8gQXV0b21hdGljYWxseSBjaGVjayBmb3Igd2FsbGV0IGFuZCBnZW5lcmF0ZSBpZiBuZWVkZWRcbiAgICAgIC8vIFRoaXMgZW5zdXJlcyBldmVyeSB1c2VyIGhhcyBhIHdhbGxldCBhdXRvbWF0aWNhbGx5XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY2hlY2tBbmRHZW5lcmF0ZVdhbGxldCgpO1xuICAgICAgfSwgNTAwKTsgLy8gU21hbGwgZGVsYXkgdG8gZW5zdXJlIGF1dGggaXMgZnVsbHkgZXN0YWJsaXNoZWRcbiAgICAgIFxuICAgICAgcmV0dXJuIHRydWU7IC8vIFNpZ25hbCBzdWNjZXNzZnVsIGxvZ2luXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0xvZ2luIGZhaWxlZDonLCBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJyk7XG4gICAgICAvLyBFbnN1cmUgYXV0aCBzdGF0ZSBpcyByZXNldCBpZiBsb2dpbiBmYWlsc1xuICAgICAgY2xlYXJBdXRoVG9rZW5zKCk7XG4gICAgICBTZXNzaW9uUGVyc2lzdGVuY2UuY2xlYXJTbmFwc2hvdCgpO1xuICAgICAgXG4gICAgICBzZXRUb2tlbihudWxsKTtcbiAgICAgIHNldFVzZXIobnVsbCk7XG4gICAgICBzZXRJc0F1dGhlbnRpY2F0ZWQoZmFsc2UpO1xuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgICBcbiAgICAgIHJldHVybiBmYWxzZTsgLy8gU2lnbmFsIGZhaWxlZCBsb2dpblxuICAgIH1cbiAgfTtcblxuICAvLyBDbGVhciBhdXRoIHN0YXRlIC0gcmV1c2FibGUgZnVuY3Rpb24gZm9yIGJvdGggbG9nb3V0IGFuZCBmYWlsZWQgYXV0aFxuICBjb25zdCBjbGVhckF1dGhTdGF0ZSA9ICgpID0+IHtcbiAgICBjbGVhckF1dGhUb2tlbnMoKTtcbiAgICBzZXRUb2tlbihudWxsKTtcbiAgICBzZXRVc2VyKG51bGwpO1xuICAgIHNldElzQXV0aGVudGljYXRlZChmYWxzZSk7XG4gICAgU2Vzc2lvblBlcnNpc3RlbmNlLmNsZWFyU25hcHNob3QoKTtcbiAgfTtcbiAgXG4gIC8vIENsZWFyIGF1dGggc3RhdGVcbiAgY29uc3QgbG9nb3V0ID0gYXN5bmMgKCkgPT4ge1xuICAgIGxvZ0F1dGhFdmVudCgnbG9nb3V0X2luaXRpYXRlZCcpO1xuICAgIHRyeSB7XG4gICAgICAvLyBBdHRlbXB0IHRvIGNhbGwgbG9nb3V0IGVuZHBvaW50IGlmIHdlIGhhdmUgYSB0b2tlblxuICAgICAgaWYgKGdldEF1dGhUb2tlbigpKSB7XG4gICAgICAgIGF3YWl0IGFwaS5wb3N0KEFQSV9FTkRQT0lOVFMuQVVUSC5MT0dPVVQsIHt9KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZHVyaW5nIGxvZ291dDonLCBlcnJvcik7XG4gICAgICAvLyBDb250aW51ZSB3aXRoIGxvZ291dCByZWdhcmRsZXNzIG9mIEFQSSBlcnJvcnNcbiAgICB9IGZpbmFsbHkge1xuICAgICAgLy8gQWx3YXlzIGNsZWFyIGxvY2FsIHN0YXRlIGFuZCBzdG9yYWdlXG4gICAgICBjbGVhckF1dGhTdGF0ZSgpO1xuICAgICAgXG4gICAgICAvLyBMb2cgdGhlIGV2ZW50XG4gICAgICBsb2dBdXRoRXZlbnQoJ2xvZ291dF9jb21wbGV0ZScpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxBdXRoQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17eyBcbiAgICAgIHVzZXIsIFxuICAgICAgbG9naW4sIFxuICAgICAgbG9nb3V0LCBcbiAgICAgIGxvYWRpbmcsXG4gICAgICByZWZyZXNoVG9rZW4sXG4gICAgICBpc0F1dGhlbnRpY2F0ZWRcbiAgICB9fT5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L0F1dGhDb250ZXh0LlByb3ZpZGVyPlxuICApO1xufVxuXG5leHBvcnQgY29uc3QgdXNlQXV0aCA9ICgpOiBBdXRoQ29udGV4dFR5cGUgPT4ge1xuICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dChBdXRoQ29udGV4dCk7XG4gIGlmICghY29udGV4dCkge1xuICAgIHRocm93IG5ldyBFcnJvcigndXNlQXV0aCBtdXN0IGJlIHVzZWQgd2l0aGluIGFuIEF1dGhQcm92aWRlcicpO1xuICB9XG4gIHJldHVybiBjb250ZXh0O1xufTtcbiJdLCJuYW1lcyI6WyJSZWFjdCIsImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwidXNlRWZmZWN0IiwidXNlU3RhdGUiLCJ1c2VSZWYiLCJBUElfRU5EUE9JTlRTIiwiYXBpIiwiaGFzQWRtaW5CeXBhc3MiLCJieXBhc3NMb2dpbiIsImdldEF1dGhUb2tlbiIsInN0b3JlQXV0aFRva2VuIiwiY2xlYXJBdXRoVG9rZW5zIiwiVE9LRU5fS0VZIiwiVE9LRU5fRVhQSVJZX0tFWSIsIlJFRlJFU0hfVE9LRU5fS0VZIiwiVE9LRU5fVkVSSUZZX0lOVEVSVkFMIiwiU2Vzc2lvblBlcnNpc3RlbmNlIiwiU1RPUkFHRV9LRVkiLCJjYXB0dXJlU25hcHNob3QiLCJ1c2VyIiwidG9rZW4iLCJjbGVhclNuYXBzaG90Iiwic25hcHNob3QiLCJ0aW1lc3RhbXAiLCJEYXRlIiwibm93IiwiaWQiLCJ1c2VybmFtZSIsImVtYWlsIiwiYXV0aGVudGljYXRlZCIsInNlc3Npb25TdG9yYWdlIiwic2V0SXRlbSIsIkpTT04iLCJzdHJpbmdpZnkiLCJlcnJvciIsImNvbnNvbGUiLCJ3YXJuIiwicmV0cmlldmVTbmFwc2hvdCIsInNuYXBzaG90U3RyIiwiZ2V0SXRlbSIsInBhcnNlIiwiTUFYX0FHRSIsImlzRXhwaXJlZCIsInJlbW92ZUl0ZW0iLCJBdXRoQ29udGV4dCIsIkF1dGhQcm92aWRlciIsImNoaWxkcmVuIiwic2V0VXNlciIsImxvYWRpbmciLCJzZXRMb2FkaW5nIiwiaXNBdXRoZW50aWNhdGVkIiwic2V0SXNBdXRoZW50aWNhdGVkIiwic2V0VG9rZW4iLCJza2lwTmV4dFZlcmlmaWNhdGlvbiIsInNldFNraXBOZXh0VmVyaWZpY2F0aW9uIiwibG9naW4iLCJpc01vdW50ZWQiLCJ2ZXJpZnlPbk1vdW50IiwibG9nIiwidmVyaWZ5VG9rZW4iLCJpbnRlcnZhbCIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsInZlcmlmeVRva2VuRGVib3VuY2VkIiwibGFzdFZlcmlmeUF0dGVtcHQiLCJmb3JjZSIsImN1cnJlbnQiLCJyZXNwb25zZSIsImdldCIsIkFVVEgiLCJWRVJJRllfVE9LRU4iLCJzdWNjZXNzIiwiZGF0YSIsInN0YXR1cyIsInN0YXR1c0NvZGUiLCJjbGVhckF1dGhTdGF0ZSIsIm1zZyIsIkVycm9yIiwibWVzc2FnZSIsImxvZ0F1dGhFdmVudCIsImV2ZW50VHlwZSIsImRldGFpbHMiLCJ0b0lTT1N0cmluZyIsImxvZ0VudHJ5IiwiYXV0aExvZ3MiLCJsb2NhbFN0b3JhZ2UiLCJwdXNoIiwic2xpY2UiLCJlIiwiY2hlY2tBbmRHZW5lcmF0ZVdhbGxldCIsIndhbGxldFJlc3BvbnNlIiwiV0FMTEVUIiwiSU5GTyIsIndhbGxldCIsIndhbGxldF9hZGRyZXNzIiwiZ2VuZXJhdGVSZXNwb25zZSIsInBvc3QiLCJHRU5FUkFURSIsInJlZnJlc2hUb2tlbiIsInJldHJ5Q291bnQiLCJNQVhfUkVUUklFUyIsIkJBU0VfREVMQVkiLCJkZWxheSIsIk1hdGgiLCJwb3ciLCJyYW5kb20iLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJSRUZSRVNIX1RPS0VOIiwiaW5Mb2NhbFN0b3JhZ2UiLCJyZW1lbWJlck1lIiwicHJldlVzZXIiLCJlcnJvck1lc3NhZ2UiLCJlcnJvclN0YWNrIiwic3RhY2siLCJ1bmRlZmluZWQiLCJsb2dvdXQiLCJzdG9yZWRUb2tlbiIsInJlbWVtYmVyX21lIiwiTE9HT1VUIiwiUHJvdmlkZXIiLCJ2YWx1ZSIsInVzZUF1dGgiLCJjb250ZXh0Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/AuthContext.tsx\n"));

/***/ })

});